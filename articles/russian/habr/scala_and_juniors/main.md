Скала для всех
==============
**Часть 1 Типичные ошибки**

Эта статья посвящена ошибкам, которые совершают новички, ступая на тропу Scala.
И не только новички: в нашем привычном понимании aka *джуниоры*, но и
умудренные опытом программисты, с сединой в бороде. Для многих, особенно
имевших в своем бэкграунде императивные языки, такие как C/C++/Java, многие
идиомы Scala являются непонятными, более того, неочевидными. В этой серии
статей, я постараюсь рассказать об основовных ошибках, недопонятых идиомах и
вещах, которые под страхом расстрела делать не нужно. Ну что, поехали?

**Структура цикла**

 - [Типичные ошибки](#)
 - [Часть 2](#)

<cut text="Читать про ScalaCheck →">


# Вместо вступления
В свое время я попал в очень интересную ситуацию: мне, тогда еще 23х летнему
разработчику пришлось объяснять скалические идиомы старшим коллегам.
Сейчас же, я чаще общаюсь с разработчиками разного уровня, решившими освоить
Scala, так как в компании, где я работаю, существует внутренняя система
координации образовательной деятельности с курсами и проверяющими.
В данный момент я, вместе с другими проверяющими, занимаюсь проверкой и
поддержкой курсов по Scala.

Эта серия из двух статей является коллекцией ошибок, и недопонятых идиом,
совершаемых *молодыми* скалистами. Так же я добавил ряд личных рекомендаций.

> Изначально, статья должна была писаться на английском и называться так:
> "Scala for juniors and junior-seniors", но пишется она на русском. И на
> данный момент, я понятия не имею как это перевести. Статья это рассчитана
> не только на чистых джуниоров, но и на тех кто вообще впервые столкнулся
> с этим замечательным языком


## Hello world
Знаете что не так с этим кодом:

    object Main extends App {
      Console.println("Hello World: " + (args mkString ", "))
    }

Конкретно с этим примером "все так". Все будет хорошо и прекрасно работать,
пока вы не усложните код достаточно, и не встретитесь с непредсказуемым
поведением. И виной тому один трейт из стандартной библиотеки. Он называется
`DelayedInit`. Прочитать о нем вы можете [здесь](delayed-init).
Трейт `App`, который вам предлагается расширить в большинстве руководств,
расширяет трейт `DelayedInit`. Подробнее об `App` в [документации](app-doc).

> It should be noted that this trait is implemented using the DelayedInit
> functionality, which means that fields of the object will not have been
> initialized before the main method has been executed.

По-русски

> Следует учесть, что данный трейт реализован с использованием функциональности
> DelayedInit, что означает то что поля объекта не будут проинициализированы
> до выполнения main метода.

В будущем это обещают исправить:

> Future versions of this trait will no longer extend DelayedInit. 

Плохо ли использовать `App`? В сложных многопоточных приложениях я бы не стал
этого делать. А если вы пишете "Hello world"? Почему бы нет. Я стараюсь лишний
раз не связываться и использую традиционный `main` метод.

[app-doc]: http://www.scala-lang.org/api/current/scala/App.html
[delayed-init]: http://www.scala-lang.org/api/current/scala/DelayedInit.html


## Перегрузки
В Scala существует возможность перегрузки конструкторов для классов. И это —
не лучший способ решить проблему. Скажу больше, это — *не идиоматичный* способ
решения проблемы. Если говорить о практике, эта функция полезна, если ваш
Scala-код вызывается из Java, и вам необходимо такое поведение (а почему бы в
таком случае не сделать Builder)? В остальных случаях лучшая стратегия —
создание companion-object и определение в нем нескольких методов `apply`.
Самое веселое, когда ненужная перегрузка конструкторов происходит из-за не
знания о [параметрах по-умолчанию](default-parameters) (default parameters).

[default-parameters](http://docs.scala-lang.org/tutorials/tour/default-parameter-values.html)

Совсем недавно, я стал свидетелем следующего безобразия:

    case class Monster (pos: Position, health: Int, weapon: Weapon) {
      def this(pos: Position) = this(pos, 100, new Claws)
	  def this(pos: Position, weapon: Weapon) = this(pos, 100, weapon)
    }

Ларчик открывается проще:

    case class Monster(
      pos: Position,
      health: Short = 100,
      weapon: Weapon = new Claws
    )

Хотите наградить вашего монстра базукой? Не проблема:

    val dima = Monster(Position(300, 300, 20), weapon = new Bazooka)
	
Мы сделали мир лучше, монстра миролюбивее, и перестали перегружать все что
движется. Миролюбивее? Определенно. Ведь базука, это еще и музыкальный
инструмент. Вот такой:

<img src="https://habrastorage.org/files/da7/8c8/61e/da78c861e02d4cb6b190c93768e734a3.jpg"/>


## О case классах
Появление case classов в Scala это прорыв для индустриальных языков (коим Scala
к счастью является). В чем их основное преимущество? Правильно, в их
неизменяемости иммутабельности


## Неинициализируемые значения
Scala также поддерживает неинициализированные значения. Эта функциональность
как раз потребуется вам при создании beans. Давайте посмотрим на следующий
пример на Java:

    class MyClass {
        // По-умолчанию, любой наследник AnyRef инциализируется в ноль.
        // Примитивные типы инициализируются со своими значениями по-умолчанию.
        String uninitialized;
    }

То же самое можно проделать и в Scala:

    class {
      // синтаксис с нижним подчеркиванием говорит Scala, что
      // данное поле не будет инциализированно.
      var uninitialized: String = _
    }

Пожалуйста, **не делайте этого**. Инициализируйте значения везде, где можете.
Используйте подобную функциональность, только если используемый вами фреймворк
или библиотека яростно на этом настаивают. При неаккуратном использовании вы
можете получить тонны `NullPointerException`. Однако знать об этой функции
следует, однажды подобное знание сэкономит время. Если вы
хотите отложить инициализацию, используйте ключевое слово `lazy`.


[java-beans]: https://en.wikipedia.org/wiki/JavaBeans
[project-lombok]: https://projectlombok.org/
[bean-property-doc]: https://www.scala-lang.org/api/2.12.0/scala/beans/BeanProperty.html
[bean-property-alvin]: http://alvinalexander.com/scala/how-to-create-scala-javabeans-beanproperty-java-libraries
[bean-property-illustrated]: https://daily-scala.blogspot.ru/2009/09/beanproperties.html
[bool-prop]: http://www.scala-lang.org/api/2.12.0/scala/beans/BooleanBeanProperty.html


## Переизобретение enumов
Берем опытного Java разработчика и сажаем его на Scala. Не проходит и пары
дней, и он отчаянно начинает искать enumы. Не находит их, и расстраивается.
В Scala нет ключевого слова “enum” или даже “enumeration”.

Далее есть два варианта событий: или он нагуглит идиоматичное решение, или
начнет переизобретать свои перечисления. Часто лень побеждает, и мы имеем вот
это:

    object Weekdays {
      val MONDAY = 0
      // догадайтесь что будет дальше...
    }

А дальше то что? А вот что:

    if (weekday == Weekday.Friday) {
       stop(wearing, Tie)
    }

Что не так? В Scala есть идиоматичный способ создания перечислений, именуется
он ADT (Algebraic Data Types), по-русски *алгебраические типы данных*.
Используется, например в Haskell. Вот как он выглядит:

    sealed trait TrafficLight
    case object Green extends TrafficLight
    case object Yellow extends TrafficLight
    case object Red extends TrafficLight
    case object Broken extends TrafficLight

Многословно, самодельный enum конечно был короче. Зачем столько писать?
Давайте объявим следующую функцию:

    def tellWhatTheLightIs(tl: TrafficLight): Unit = tl match {
      case Red => println("No cars go!")
      case Green => println("Don't stop me now!")
      case Yellow => println("Ooohhh you better stop!")
    }

И получим:

    warning: match may not be exhaustive.
    It would fail on the following input: Broken
           def tellWhatTheLightIs(tl: TrafficLight): Unit = tl match {
                                                            ^
    tellWhatTheLightIs: (tl: TrafficLight)Unit

Мы получаем перечисление, свободное от привязки к каким либо константам, а так
же проверку на исчерпываемость при сопоставлении с образцом. И да, если вы
используете "enumы для бедных", как их обозвал один мой небезызвестный коллега,
используйте сопоставление с образцом. Это наиболее идиоматичный способ. Самое
интересное, что об этом написано в начале замечательной книги Programming in
Scala, написаной Мартином Одерски. Но не все скалисты добираются до этой книги.
TL;DR, как говорится.

> А где вы видели трехстраничный Magnum Opus?

Неплохо про алгебраические типы данных рассказано, как ни странно, в
[Википедии][adt-wiki]. Касательно Scala, есть достаточно доступный
[пост][scala-adt] и [презентация][scala-adt-2], которая, возможно,
покажется вам интересной.

[adt-wiki]: https://en.wikipedia.org/wiki/Algebraic_data_type
[scala-adt]: https://gleichmann.wordpress.com/2011/01/30/functional-scala-algebraic-datatypes-enumerated-types/
[scala-adt-2]: http://tpolecat.github.io/presentations/algebraic_types.html#18


## А где псевдонимы типов? (Type aliases)
По возможности используйте псевдонимы типов.
Это делает ваш код более читаемым, согласитесь, что `Map[Username, Key]`
выглядит лучше, чем `Map[String, String]`. Больше примеров вы можете найти
[здесь][type-aliases], просто промотайте чуть ниже до раздела с примерами.

[type-aliases]: http://www.scala-lang.org/files/archive/spec/2.12/04-basic-declarations-and-definitions.html#type-declarations-and-type-aliases


# Сопоставление с образцом
Горячо любимая мною фича Scala и ряда других функциональных языков, например,
Erlang. А знаете, за что я недолюбливаю курс, преподаваемый Мартином Одерски
на CourseEra? Не знаю как сейчас, однако когда я этот самый курс проходил,
Pattern Matching шел, чуть ли не шестым разделом. И в рекурсивных функциях
приходилось использовать if expression. Чем это плохо? А вот чем.
Люди выучиываются, и паттерны в их голове остаются, и везде где следовало
бы использовать сопоставление с образцом, используется конструкция if-else.
Конструкция, которая не всегда и не везде применима.

## Еще раз о присваивании
Давайте вернемся к операции присваивания и увидим, что она не так проста,
как может показаться на первый взгляд:

    // это было простым связыванием, ничто не предвещало беды
    scala> val address = ("localhost", 80)
    address: (String, Int) = (localhost,80)

    scala> val (host, port) = address
    host: String = localhost
    port: Int = 80

Мы только что разобрали кортеж на две переменные, однако кортежами дело
не ограничивается:

    scala> val first::rest = List(1,2,3,4,5)
    first: Int = 1
    rest: List[Int] = List(2, 3, 4, 5)

Аналогичные операции мы можем провести и с `case class`:

    case class Person(name: String, age: Int)

    val max = Person("Max", 36)
    // max: Person = Person(Max,36)

    val Person(n, a) = max
    // n: String = Max
    // a: Int = 36

Более того:

    scala> val p @ Person(n, a) = max
    // p: Person = Person(Max,36)
    // n: String = Max
    // a: Int = 36

В последнем случае по имени “p” мы получим саму запись case class,
по имени “n” получим имя, по “a” — возраст.

Как видите, операция присваивания не так проста, как кажется. Она также
является скрытой от беглого взгляда операцией сопоставления с образцом.
Подобное реализовано и в других языках, например Python и Erlang.


# О списках
## Headshot
У Option есть `get`, у списка есть `head`, а еще у него есть `init` и
`tail`. Вот что мы можете получить, вызывая вышеописанные методы:

    // Для пустого списка:
    init: java.lang.UnsupportedOperationException
    head: java.lang.NoSuchElementException
    last: java.lang.NoSuchElementException
    tail: java.lang.UnsupportedOperationException

конечно, с вами этого никогда не случится, если вы проверяете лист на пустоту.

> Начинающий скалист будет делать это используя пресловутую конструкцию if-else.

Каждый раз? Да ладно, с этим списком никогда ничего не может случиться. Он
никогда не будет пустым? Правда?

Вызов `list.head` и сотоварищей — один из самых лучших способов выстрелить себе
в голову при работе со списками.

> Извивайтесь гремучей змеей, делайте все возможное чтобы не
> использовать `list.head` и его друзей.

Вместо `head` неплохим вариантом будет использование метода `headOption`, если
для вас наличие дополнительного контейнера — не проблема. Метод
`lastOption` ведет себя аналогично. Если вы каким-либо образом привязаны к
индексам, можете воспользоваться методом `isDefinedAt`, который принимает
целочисленный аргумент (индекс) в качестве параметра. Все описанное выше
по-прежнему подразумевает проверки, которые можно забыть. Найдутся еще тысяча и
одна причина чтобы вы их опустили сознательно. Правильной и идиоматичной
альтернативой будет использование сопоставления с образцом. Тот факт, что лист
является алгебраическим типом, не даст вам забыть о `Nil`, вы сможете спокойно
избежать вызовов `head` и `tail`, сэкономить несколько строчек кода:

    def printRec(list: List[String]): Unit = list match {
      case Nil  => ()
      case x:xs => println(x)
                   printRec(xs)
    }

*Немного о производительности*
> С точки зрения производительности, для односвязного списка, коим
> является скаловский `List` (он же `scala.collection.immutable.List`)
> Наиболее дешевой операцией будет запись в начало списка, нежели
> в конец. Для записи в конец списка требуется пройти весь список до
> конца. Сложность записи в начало списка O(1), в конец O(n).
> Не забывайте об этом.

## Возможно, список
В коде только что познакомившихся со Scala с завидной периодичностью
встречаются в аргументах функции, или в качестве возвращаемого типа —
`Option[List[A]]`. Как встречаю, спрашиваю написавшего, зачем он нужен. А мне
отвечают: «Так у нас список может быть, а может и не быть, что же я буду
вместо него `null` использовать?». И слышу это от достаточно взрослых инженеров.
Список может быть пустым так же, как и `Option`, поэтому можно спокойно
передавать пустой список, если что-то пойдет не так. Дополнительный
контейнер не нужен.


# Опшны через боль
Многие из вас уже знакомы с типом “Optional” в Java 8.
Тип “Option” выполняет те же функции. Более того, многим
джавистам тип может быть знаком по библиотеке Guava от Google.

Да, этот тип используется для избегания `null`, а в последствии — и
`NullPointerException`. Да, у него есть методы `isEmpty` и `nonEmpty`. В
варианте Guava есть метод “isPresent”. И многие, кто использовал или не
использовал `Optional` в Java или других языках, неправильно использует его в
Scala.

Неправильное использование Option — распространенная проблема.
Option, в **первую очередь**, нужен,чтобы **концептуально** показать
возможно отсутствующую сущность. А не убегать от NPE. Да, проблема есть, и
проблема серьезная. Кто-то для этого даже язык свой изобретает.
Но давайте вернемся к неправильному использованию Option в Scala:

    if (option.isEmpty)
      default
    else
      // может взорватся c NoSuchElementException (без проверки)
      option.get

Мы делаем проверку, и у нас, вроде бы, ничто не должно взорваться. Поверьте,
в промышленном коде можно ошибиться, и в условии может оказаться совсем не то
выражение, которое ожидалось. И даже тесты могут быть написаны неправильно Не
вами, так вашими предшественниками. Некоторые разработчики имеют свойство
подгонять тесты под уже «работающий» код.

Правильнее и **короче** код можно записать так:

    option getOrElse default

Чем компактнее ваш код, тем легче найти в нем ошибку, и тем сложнее эту ошибку
допустить. Существует полезный метод `orElse`, который позволяет сцеплять
различные Option.

Зачастую вам нужно трансформировать значение внутри Option, если оно вообще там
имеется. Для этого существует метод `map`, он вынимает значение,
преобразовывает его и упаковывает обратно в контейнер.

    val messageOpt = Some("Hello")
    val updMessageOpt = messageOpt.map(msg => "$mgs cruel world!")

    updMessageOpt: Option[String]

А иногда бывает и такое:

    val messageOptOpt = Some(Some("Hello"))

Option могут безмерно вкладываются друг в друга. Эту проблему решает метод
`flatMap` или метод `flatten`. Первый работает аналогично `map` — он
трансформирует внутреннее значение, однако при этом уплощает структуру, второй
просто упрощает структуру:

    val updMessageOptOpt = messageOptOpt.flatMap(msg => "$mgs cruel world!")
    res0: updMessageOptOpt: Option[String]

    messageOptOpt.flatten == Some("Hello")
    res1: Option[String] = Some(Hello)

В Scala существует еще один механизм который заметно облегчает работу с
Option, и это... “For comprehension”.`

    val ox = Some(1)
    val oy = Some(2)
    val oz = Some(3)

    for (x <- ox; y <- oy; z <- oz)
      yield x + y + z

    // res0: Option[Int] = 6

Если какой-то из Option-типов будет равен `None`, после `yield` пользователь
получит пустой контейнер, вернее, значение пустого контейнера. В случае с
Option это None. В случае со списком — Nil.

И главное, старайтесь сделать все, лишь бы не вызывать метод `get`. Это ведет
к потенциальным проблемам.

> Я знаю что вы все проверили и молодец, уверен ваша мама тоже так думает,
> но это не дает вам повода лишний раз дергать get


# Кортежи
Наличие кортежей (tuples) — замечательнейшая особенность ряда функциональных (и
не только) языков. В функциональных языках кортежи очень удобно использовать
аналогично записям (records). Описываем кортеж с нужными данными и оборачиваем
в новый тип, например, используя `newtype` в [Haskell](haskell_newtype). В
чисто функциональных языках без кортежей никуда: они позволяют замечательно
представлять словари (dictionaries), без них было [конволюция](convolution) была
бы менее наглядной.

Scala — язык объектно-ориентированный. Да, с поддержкой элементов
функционального программирования. Уверен, что многие со мной не согласятся, но
давайте не будем забывать, что в Scala все есть объект. Наличие case-классов во
многом снижает необходимость кортежец: мы получаем неизменяемые записи,
которые тоже можно сопоставлять с образцами (об этом расскажем далее),
с каждым case-классом уже связан свой тип.

Кортежи приходится использовать, и пришедшим из объектно-ориентированных
Языков эти языковые средства — в диковинку. Во-первых, их не именуют.

> Если кортеж не используется как анонимная помойка, его следует
> именовать

Для функционального стиля хорошим тоном считается использование
псевдонимов для типов (type aliasing):

    type Point = (Double, Double)

В будущем вы ссылаетесь на вполне себе именованные типы, и у вас не будет
вот таких страшных вещей:

    // плохо
    def drawLine(x: (Double, Double), y: (Double, Double)): Line = ???

    // не плохо
    def drawLine(x: Point, y: Point): Line = ???


В Scala, достучаться до элемента кортежа можно по индексу. Например:

    // Плохо!
    val y = point._2 // второй элемент

Особенно печально это выглядит при работе с коллекциями:

    // Печально!
    points foreach { point: Point =>
      println(s"x: ${point._1}, y: ${point._2}")
    }

И так делать не надо. Конечно, есть исключительные случаи, когда подобного
рода меры повышают читаемость:

    // Оправданно
    rows.groupBy(_._2)

Но в большинстве случаев, синтаксис с подчеркиванием лучше не использовать.
Про него вообще лучше забыть, и не вспоминать. В Scala существуют более
естественные способы обходиться без подобного синтаксиса.

> В Scala всегда можно обойтись без pair._2. И это нужно делать.

Чтобы понять и разобраться, почему все именно так, давайте обратимся к
функциональным языкам.

Вопрос: Почему индексы списков в Scala начинаются с 0, а кортежей — с единицы?
Ответ: потому что так исторически сложилось. В SML для доступа к элементам
кортежа существуют [функции](tuples_in_sml) `#1` и `#2`. В `Haskell` существуют
всего две функции для доступа к элементам кортежа: “fst” и “snd”.

    -- Как-то так. В Haskell аргументы функции идут сразу же после имени
    -- этой самой функции. Без скобок.
    fst tuple

А вот получить третий или пятый элемент кортежа просто так уже не получится. Не
верите? А [зря](tuples_in_haskell). И не поверите, если я вам скажу, что
сопоставление с образцом — *наиболее естественный*. И не только в `Haskell`.

**Ocaml**

    let third (_, _, elem) = elem

**Erlang**

    1> Tuple = {1,3,4}.
    {1,3,4}

    2> Third = fun ({_Fst, _Snd, Thrd}) -> Thrd end.
    #Fun<erl_eval.6.50752066>

    3> Third(Tuple).
    4

**Python**
А вот вам пример не из функционального языка:

    >> (ip, hostname) = ("127.0.0.1", "localhost")
    >>> ip
    '127.0.0.1'
    >>> hostname
    'localhost'
    >>>

А теперь давайте применим полученные знания к **Scala**

    // предположим, у нас есть прямоугольник
    trait Rectangle {
      def topLeft: Point
      ...
    }

    // сопоставления с образцом при связывании
    val (x0, y0) = rectangle.topLeft

    // сопоставление с образцом внутри лямбды:
    points foreach { case (x, y) =>
      println(s"x: ${x}, y: ${y}")
    }

И да, стандартный механизм сопоставления используя ключевое слово `match` тоже
никто не отменял.

> Также кортежи можно использовать как анонимные помойки, и это
> порой оправданно.

Дело в том, что во многих функциональных языках существует сопоставление
с образцом на уровне сигнатур функций:

    -- немного кода на haskell
    -- здесь описываются типы:
    map :: (a -> b) -> [a] -> [b]

    -- а вот тут сопоставление с образцом на уровне
    -- сигнатуры функции

    -- если нашим аргументом является
    -- пустой список:
    map _ []  =  []

    -- более идиоматично было бы использование x:xs но, считаю, для не
    -- знающих Haskell head:tail будет нагляднее. : - оператор именуемый cons
    -- является эквивалентным скаловскому ::
    map fun (head:tail) = fun head : map fun tail

Аналогично для SML или Erlang. Scala такой возможности лишена. Поэтому
кортежи можно использовать для группировки и последующего сопоставления
с образцом. И да, это будет вам стоить производительности (каждый раз
будет создаваться дополнительный объект в памяти):

    // похоже на Haskell, но не то :(
    def map [A, B] (f: A => B, l: List[A]): List[B] = (f, l) match {
        case (f, Nil) => List.empty
        case (f, head::tail) => f(head) :: map(f, tail)
    }

Зачастую бывает необходимо обновить значение в каком-то из элементов
кортежа. Для этого подойдет метод “copy”.

    val dog = ("Rex", 13)
    val olderDog = tuple.copy(_2 = 14)


[scala-wiki-tuples]: https://en.wikibooks.org/wiki/Scala/Tuples
[convolution]: https://en.wikipedia.org/wiki/Convolution_(computer_science)
[tuples_in_haskell]: http://stackoverflow.com/questions/15558278/how-to-get-nth-element-from-a-10-tuple-in-haskell
[tuples_in_sml]: http://www.cs.cornell.edu/courses/cs312/2004fa/lectures/lecture3.htm
[haskell_newtype]: https://wiki.haskell.org/Newtype


## for i = 1, j = k, k = ???
Главное, что вам следует знать про генераторы списков, или, как их еще
Называют, “for comprehensions”, что основное их предназначение —
не в реализации циклов.

Эту синтаксическую конструкцию можно использовать не только для
итерации по элементам коллекций и фильтрации. Более того, использование
подобной конструкции для итерации будет достаточно дорогостоящей
процедурой. Цикл `while` или использование хвостовой рекурсии — намного дешевле.

For comprehension” представляет собой синтаксический сахар для методов
`map`, `flatMap` и `withFilter`. Ключевое слово `yield` используется
для последующей агрегации значений в результирующей структуре.

Замечательнейшее [видео][fors-video], в котором подробно рассказывается
все, что вы хотели знать про генераторы списков.

[fors-video]: https://www.youtube.com/watch?v=WDaw2yXAa50

> И пожалуйста, не называйте переменные i, j, k. Я понимаю, что фортан
> и его наследие живут до сих пор, но не надо тащить это из языка в язык.
> При правильном использовании `for`, вам не придется использовать эти
> несчастные переменные




TODO: это не ошибка это рекомендация
## Зачем лепить getterы и setterы, когда есть Scala Beans
Scala предоставляет отличное взаимодействие с Java. Она также способна
облегчить вам жизнь при дизайне так называемых Beans. Если вы не знакомы с
Java или концепцией Beans, советуем [ознакомиться][java-beans].

В Scala имеется механизм, схожий с [Project Lombok][project-lombok]. Он
называется BeanProperty и является частью стандартной библиотеки.
Все, что вам нужно, — создать bean и добавить аннотацию “BeanProperty” к каждому
полю, для которого хотите создать getter или setter.
[Здесь][bean-property-alvin] вы можете подробнее прочитать об использовании
данного свойства. Документацию к “BeanProperty” вы можете найти
[здесь][bean-property-doc].

Если вы хотите создать getter и setter для переменной логического типа,
[данный класс][bool-prop] может вам в этом помочь: на выходе вы получите метод
вида `isProperty`.



--------------------------------------------------------------------------------


# Список литературы
В заключении этой статьи я бы посоветовал вам ознакомиться со статьей
[Effective Scala][effective-scala]. А также:

  TODO:

[effective-scala]: http://twitter.github.io/effectivescala/


--------------------------------------------------------------------------------

# Приложение
## Установка и настройка
А начнем мы с потугов поставить несчастную Скалу и подключить ее в проект.
Как это выглядит у обычных людей? Для начала надо скачать JDK, если вы конечно
не джавист, кложурист или еще какой маргинал. Обязательно прописать PATH к
javac, или убедиться в том что он прописан, поставить *вашу любимую IDE*,
скачать скалу, прописать ее, скачать sbt прописать его. Ничего не забыли?
Зачастую нужно иметь несколько разных версий Scala на вашем компьютере. Какой
кошмар! Самое время паниковать! Или использовать [SdkMan!][sdkman].
Если в двух словах, этот инструмент позволяет устанавливать различные системы
сборки и jvm-языки, и управлять их версиями. Так что применителен он не только
к Scala.

[sdkman]: http://sdkman.io/install.html


## Муки выбора IDE
Каждый раз я слышу вопрос: "А какую IDE для Scala использовать?". И знаете
какой ответ я даю? Все и сразу. Поставьте ScalaIDE, поставьте IDEA, установите
ENISME. И выберите то что вам подходит. Для работы я использую IntelliJ IDEA.
Для личных проектов vim/emacs, ScalaIDE я использую, когда IDEA снесет крышу.
Поверьте, и такое бывает. Но как показывает практика, большинство разработчиков
остаются с IntelliJ IDEA. И для многих компаний/проектов она является
стандартом де-факто. В любом случае мой совет -- ставить все. И использовать
конкретные инструменты, для конкретных задач.

IntelliJ IDEA Community Edition прекрасно поддерживает и Scala, и Dotty. И
мы рекомендуем использовать ее. Вы также можете воспользоваться ScalaIDE
или ENSIME Никто вам не запрещает вручную настроить Vim.

> Если все-таки вы собираетесь устанавливать Scala-IDE, проще всего сделать
> это, скачав готовую сборку IDE (нажав кнопку Download IDE) или пройдя по
> ссылке ниже. Вы также можете установить ее как плагин для Eclipse, конечно,
> если вы знаете, что делаете ☺.


## Плюсы и минусы выбора конкретной IDE
Выбирая IntelliJ IDEA, вы получаете лучшую на данный момент поддержку Scala,
огромное количество плагинов и достаточно высокую скорость работы.
Минус — если вам потребуется использовать Play framework, придется приобрести
полную версию продукта, что стоит денег. Хотя при невысоком уровне дискомфорта
можно по-прежнему обходиться Community Edition. Если у вас есть полная версия
(Ultimate), думаю, для вас выбор очевиден.

Выбирая Scala IDE, вы получаете Eclipse с отличной официальной поддержкой
Scala. Плюсы: Eclipse как свободная платформа с огромным количеством
доступных плагинов — платных и бесплатных. Вы получаете официальную
поддержку (что немаловажно). Также Play framework для Scala IDE будет работать
"из коробки". Вы его ставите и пользуетесь.

ENSIME — для тех, кто любит Vim или Emacs. Очень хорошо сделана поддержка для
Scala, и поддержку вашего любимого текстового редактора можно выделить в
качестве основного плюса. Не добавить, не убавить.

