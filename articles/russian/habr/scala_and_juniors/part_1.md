Пометки для начинающего скалиста
================================
**Часть 1**

Эта статья ~набор заметок~ посвящена ошибкам, которые совершают новички,
ступая на тропу Scala. И не только  джуниоры, но и умудренные опытом
программисты, с сединами в бороде, решившиые испробовать Scala. Для
многих, особенно имевших в своем арсенале лишь императивные языки, такие как C,
C++ или Java, многие идиомы Scala являются непонятными, более того,
неочевидными. В этой серии статей, являющейся сборником заметок о Scala, я
постараюсь рассказать об основных ошибках, недопонятых идиомах и вещах,
которые под страхом расстрела делать не нужно. Ну что, поехали?

**Структура цикла**

 - [Часть 1](#)
 - [Часть 2](#)

<cut text="Об ошибках начинающих скалистов →">


# Вместо вступления
В самом начале своей карьеры я попал в очень интересную ситуацию: мне, тогда
еще совсем юному разработчику пришлось объяснять скалические идиомы своим
старшим коллегам. Так получилось, и я благодарен жизни за этот, во многом
бесценный опыт. Сейчас я помогаю в освоении Scala разработчикам разного уровня:
от мала до велика: в компании где я работаю, существует внутренняя система
координации образовательной деятельности.В данный момент я, вместе с другими
проверяющими, занимаюсь проверкой и поддержкой курсов по Scala.

> Изначально, статья должна была писаться на английском и называться так:
> "Scala for juniors and junior-seniors", но пишется она на русском. И на
> данный момент, я понятия не имею как это перевести. Статья это рассчитана
> не только на чистых джуниоров, но и на тех кто вообще впервые столкнулся
> с этим замечательным языком

А еще в этой серии статей, вы не увидите ярковыраженной структуры. Она есть,
но не выраженная так ярко и отчетливо как хотелось бы. В первой части мы
поговорим об основных идиомах Scala и других функциональных языков. Во-второй
обсудим идиомы объектно-ориентированные. И начнем мы с наиболее недооцененной
возможности Scala -- псевдонимах типов (type aliases).


## О псевдонимах типов
Многим начинающим разработчикам (не имевшим доселе опыт с typedef), данная
функция языка кажется бесполезной. В C/C++ typedef позволяет создавать новые
имена для шаблонных типов, а также скрывать за красивыми абстракциями
машинно-зависимые типы с длинными именами `unsigned long long`.

В таких языках как Ocaml и Haskell имеется ключевое слово type, семантика
которого намного сложнее чем в Scala. Например, ключевое слово `type` позволяет
создавать не только [синонимы типов](type-synonym), но и
[алгебраические типы данных](adt-wiki):

[type-synonym]: https://wiki.haskell.org/Type_synonym
[adt-wiki]: https://en.wikipedia.org/wiki/Algebraic_data_type

    (* Пример на Ocaml*)
    type suit = Club | Diamond | Heart | Spade;;

В Scala, функциональность объявляемая при помощи ключевого слова `type`
ограничивается синонимизацией типов. Для чего вообще стоит давать уже известным
типам другие имена? Во-первых это добавляет дополнительную семантическую
нагрузку, и, например, смысл типа DateString становится более понятным чем
просто String, а `Map[Username, Key]` выглядит лучше, чем
`Map[String, String]`. Во-вторых, синонимизация позволяет сократить большие
и сложные сигнатуры типов: `Map[Username, Key]` конечно неплохо, однако
`Keystore` намного короче, и понятней.

Конечно же у типов-синонимов есть и свои недостатки: Вы видите тип Person, и
не можете понять, объект это, класс или псевдоним.

Злоупотреблять данным средством определенно не стоит, однако есть ряд ситуацией
когда они действительно будут полезными (по необходимости):

 - у вас есть функция которая может быть проассоциированна с определенным
   действием. Это действие вполне можно проименовать и не путать читателя
   сигратурами вроде `() => Unit`, и назвать это тип функций `Action`.
 - вы абстрагируетесь над Коллекцией[Коллекций, СКоллекциями[Упс]]
 - вы добавляете дополнительную сематнтическую информацию к существующему типу

Больше примеров вы можете найти [здесь](type-aliases), просто промотайте чуть
ниже до раздела с примерами.

[type-aliases]: http://www.scala-lang.org/files/archive/spec/2.12/04-basic-declarations-and-definitions.html#type-declarations-and-type-aliases


## Еще раз о присваивании
Присваивание, это не совсем то что вы думаете. Давайте рассмотрим эту операцию
и увидим, что она не так проста, как может показаться на первый взгляд:

    // это было простым связыванием, ничто не предвещало беды
    scala> val address = ("localhost", 80)
    address: (String, Int) = (localhost,80)

    scala> val (host, port) = address
    host: String = localhost
    port: Int = 80

Мы только что разобрали кортеж на две переменные, однако кортежами дело не
ограничивается:

    scala> val first::rest = List(1,2,3,4,5)
    first: Int = 1
    rest: List[Int] = List(2, 3, 4, 5)

Аналогичные операции мы можем провести и с `case class`:

    case class Person(name: String, age: Int)

    val max = Person("Max", 36)
    // max: Person = Person(Max,36)

    val Person(n, a) = max
    // n: String = Max
    // a: Int = 36

Более того:

    scala> val p @ Person(n, a) = max
    // p: Person = Person(Max,36)
    // n: String = Max
    // a: Int = 36

В последнем случае по имени `p` мы получим саму запись case class, по имени `n`
получим имя, по `a` — возраст.

Искушенный читатель уже заметил, что присваивание ведет себя точно также, как
и сопоставление с образцом. Подобная функциональность реализована и в других
языках, например Python и Erlang. Используйте эту функциональность в первую
очередь для распаковки структур данных. Но не злоупотребляйте: распаковка
сложных структур данных очень сильно ухудшает читаемость.


### Options
Многие из вас уже знакомы с типом `Optional` в Java 8. Тип `Option` выполняет
те же функции. А многим джавистам тип может быть знаком по гугловской Guava.

Да, `Optional` используется для избегания `null`, а в последствии — и
`NullPointerException`. Да, у него есть методы `isEmpty` и `nonEmpty`. В
варианте Guava есть метод `isPresent`. И многие, кто использовал или не
использовал `Optional` в Java или других языках, неправильно использует его в
Scala.

> Однако не все в курсе что в той же Guava у Optionalов определен метод
> transform, который ведет себя аналогично скаловскому map.

Неправильное использование `Option` — распространенная проблема. `Option`, в
**первую очередь**, нужен,чтобы **концептуально** показать возможно
отсутствующую сущность. А не убегать от NPE. Да, проблема есть, и проблема
серьезная. Кто-то для этого даже язык свой изобретает. Но давайте вернемся к
неправильному использованию `Option` в Scala:

    if (option.isEmpty)
      default
    else
      // может взорватся c NoSuchElementException (без проверки)
      option.get

Мы делаем проверку, и у нас, вроде бы, ничто не должно взорваться. Поверьте,
в промышленном коде можно ошибиться, и в условии может оказаться совсем не то
выражение, которое ожидалось. И даже тесты могут быть написаны неправильно Не
вами, так вашими предшественниками.

> Вообще, в примере выше есть еще одна проблема. Ваш flow зависит от
> какого-то Boolean, и целостность его нарушается.

Некоторые разработчики имеют свойство подгонять тесты под уже «работающий» код.
Правильнее и **короче** вышеприведенный код можно записать так:

    option getOrElse default

Чем компактнее ваш код, тем легче найти в нем ошибку, и тем сложнее эту ошибку
допустить. Существует полезный метод `orElse`, который позволяет сцеплять
различные `Option`.

Зачастую вам нужно трансформировать значение внутри Option, если оно вообще
там имеется. Для этого существует метод `map`, он вынимает значение,
преобразовывает его и упаковывает обратно в контейнер.

    val messageOpt = Some("Hello")
    val updMessageOpt = messageOpt.map(msg => "$mgs cruel world!")

    updMessageOpt: Option[String]

А иногда бывает и такое:

    val messageOptOpt = Some(Some("Hello"))

`Option` могут безмерно вкладываются друг в друга. Эту проблему решает метод
`flatMap` или метод `flatten`. Первый работает аналогично `map` — он
трансформирует внутреннее значение, однако при этом уплощает структуру, второй
просто упрощает структуру:

    val updMessageOptOpt = messageOptOpt.flatMap(msg => "$mgs cruel world!")
    res0: updMessageOptOpt: Option[String]

    messageOptOpt.flatten == Some("Hello")
    res1: Option[String] = Some(Hello)

В Scala существует еще один механизм который заметно облегчает работу с
Option, и это... “For comprehension”.

    val ox = Some(1)
    val oy = Some(2)
    val oz = Some(3)

    for {x <- ox; y <- oy; z <- oz}
      yield x + y + z

    // res0: Option[Int] = 6

Если какой-то из `Option`-типов будет равен `None`, после `yield` пользователь
получит пустой контейнер, вернее, значение пустого контейнера. В случае с
`Option` это `None`. В случае со списком — `Nil`.

И главное, старайтесь сделать все, лишь бы не вызывать метод `get`. Это ведет
к потенциальным проблемам.

> Я знаю что вы все проверили и молодец, уверен ваша мама тоже так думает,
> но это не дает вам повода лишний раз дергать get


### Списки
У `Option` есть `get`, у списка есть `head`, а еще у него есть `init` и `tail`.
Вот что мы можете получить, вызывая вышеописанные методы у пустого списка:

    // Для пустого списка:
    init: java.lang.UnsupportedOperationException
    head: java.lang.NoSuchElementException
    last: java.lang.NoSuchElementException
    tail: java.lang.UnsupportedOperationException

Конечно, с вами этого никогда не случится, если вы проверяете лист на пустоту.

> Начинающий скалист будет делать это используя на своем пути
> пресловутую конструкцию if-else.

Каждый раз? Да ладно, с этим списком никогда ничего не может случиться. Он
никогда не будет пустым? Правда?

Вызов `list.head` и сотоварищей — один из самых лучших способов выстрелить себе
в голову при работе со списками.

> Извивайтесь гремучей змеей, делайте все возможное чтобы не
> использовать `list.head` и его друзей.

Вместо `head` неплохим вариантом будет использование метода `headOption`.
Метод `lastOption` ведет себя аналогично. Если вы каким-либо образом привязаны
к индексам, можете воспользоваться методом `isDefinedAt`, который принимает
целочисленный аргумент (индекс) в качестве параметра. Все описанное выше
по-прежнему подразумевает проверки, которые можно забыть. Найдутся еще тысяча и
одна причина чтобы вы их опустили сознательно. Правильной и идиоматичной
альтернативой будет использование сопоставления с образцом. Тот факт, что лист
является алгебраическим типом, не даст вам забыть о `Nil`, вы сможете спокойно
избежать вызовов `head` и `tail`, сэкономить несколько строчек кода:

    def printRec(list: List[String]): Unit = list match {
      // вы также можете сопоставить одноэлеметный список, как и список из
      // n, k элементов, если захотите вот она мощь!
      case Nil  => ()
      case x:xs => println(x)
                   printRec(xs)
    }

*Немного о производительности*
> С точки зрения производительности, для односвязного списка, коим
> является скаловский `List` (он же `scala.collection.immutable.List`)
> Наиболее дешевой операцией будет запись в начало списка, нежели
> в конец. Для записи в конец списка требуется пройти весь список до
> конца. Сложность записи в начало списка O(1), в конец O(n).
> Не забывайте об этом.


### Опшны + Списки
В коде только что познакомившихся со Scala с завидной периодичностью
встречаются в аргументах функции, или в качестве возвращаемого типа —
`Option[List[A]]`. Как встречаю, спрашиваю написавшего, зачем он нужен. А мне
отвечают: «Так у нас список может быть, а может и не быть, что же я буду
вместо него `null` использовать?». И слышу это от достаточно взрослых инженеров.
Список может быть пустым так же, как и `Option`, поэтому можно спокойно
передавать пустой список, если что-то пойдет не так. Дополнительный
контейнер не нужен.


### Кортежи
Наличие кортежей (tuples) — замечательнейшая особенность ряда функциональных (и
не только) языков. В функциональных языках кортежи очень удобно использовать
аналогично записям (records). Описываем кортеж с нужными данными и оборачиваем
в новый тип, например, используя `newtype` в [Haskell](haskell_newtype). В
чисто функциональных языках без кортежей никуда: они позволяют замечательно
представлять словари (dictionaries), без них было [конволюция](convolution) была
бы менее наглядной.

> В некоторых языках, таких как Erlang, записи появились позже
> кортежей. Более того, записи (records) в Erlang так же являются кортежами.

[haskell_newtype]: https://wiki.haskell.org/Newtype
[convolution]: https://en.wikipedia.org/wiki/Convolution_(computer_science)

Scala — язык объектно-ориентированный. Да, с поддержкой элементов
функционального программирования. Уверен, что многие со мной не согласятся, но
давайте не будем забывать, что в Scala все есть объект. Наличие case-классов во
многом снижает необходимость кортежей: мы получаем неизменяемые записи,
которые тоже можно сопоставлять с образцами (об этом расскажем далее),
с каждым case-классом уже связан свой тип.

Кортежи приходится использовать, и пришедшим из объектно-ориентированных
Языков эти языковые средства — в диковинку. Во-первых, их не именуют.

> Если кортеж не используется как анонимная помойка, его следует
> именовать

Для функционального стиля хорошим тоном считается использование упомянутых ранее
псевдонимов для типов (type aliasing):

    type Point = (Double, Double)

В будущем вы ссылаетесь на вполне себе именованные типы, и у вас не будет
вот таких страшных вещей:

    // плохо
    def drawLine(x: (Double, Double), y: (Double, Double)): Line = ???

    // не плохо
    def drawLine(x: Point, y: Point): Line = ???


В Scala, достучаться до элемента кортежа можно по индексу. Например:

    // Плохо!
    val y = point._2 // второй элемент

Особенно печально это выглядит при работе с коллекциями:

    // Печально!
    points foreach { point: Point =>
      println(s"x: ${point._1}, y: ${point._2}")
    }

И так делать не надо. Конечно, есть исключительные случаи, когда подобного
рода меры повышают читаемость:

    // Оправданно
    rows.groupBy(_._2)

Но в большинстве случаев, синтаксис с подчеркиванием лучше не использовать.
Про него вообще лучше забыть, и не вспоминать. В Scala существуют более
естественные способы обходиться без подобного синтаксиса.

> В Scala всегда можно обойтись без pair._2. И это нужно делать.

Чтобы понять и разобраться, почему все именно так, давайте обратимся к
функциональным языкам.

Вопрос: Почему индексы списков в Scala начинаются с 0, а кортежей — с единицы?
Ответ: потому что так исторически сложилось. В SML для доступа к элементам
кортежа существуют [функции](tuples_in_sml) `#1` и `#2`. В `Haskell` существуют
всего две функции для доступа к элементам кортежа: “fst” и “snd”.

    -- Как-то так. В Haskell аргументы функции идут сразу же после имени
    -- этой самой функции. Без скобок.
    fst tuple

А вот получить третий или пятый элемент кортежа просто так уже не получится. Не
верите? А [зря](tuples_in_haskell). И не поверите, если я вам скажу, что
сопоставление с образцом — *наиболее естественный*. И не только в `Haskell`.

**Ocaml**

    let third (_, _, elem) = elem

**Erlang**

    1> Tuple = {1,3,4}.
    {1,3,4}

    2> Third = fun ({_Fst, _Snd, Thrd}) -> Thrd end.
    #Fun<erl_eval.6.50752066>

    3> Third(Tuple).
    4

**Python**
А вот вам пример не из функционального языка:

    >> (ip, hostname) = ("127.0.0.1", "localhost")
    >>> ip
    '127.0.0.1'
    >>> hostname
    'localhost'
    >>>

А теперь давайте применим полученные знания к **Scala**

    // предположим, у нас есть прямоугольник
    trait Rectangle {
      def topLeft: Point
      ...
    }

    // сопоставления с образцом при связывании
    val (x0, y0) = rectangle.topLeft

    // сопоставление с образцом внутри лямбды:
    points foreach { case (x, y) =>
      println(s"x: ${x}, y: ${y}")
    }

И да, стандартный механизм сопоставления используя ключевое слово `match` тоже
никто не отменял.

> Также кортежи можно использовать как анонимные помойки, и это
> порой оправданно.

Дело в том, что во многих функциональных языках существует сопоставление
с образцом на уровне сигнатур функций:

    -- немного кода на haskell
    -- здесь описываются типы:
    map :: (a -> b) -> [a] -> [b]

    -- а вот тут сопоставление с образцом на уровне
    -- сигнатуры функции

    -- если нашим аргументом является
    -- пустой список:
    map _ []  =  []

    -- более идиоматично было бы использование x:xs но, считаю, для не
    -- знающих Haskell head:tail будет нагляднее. : - оператор именуемый cons
    -- является эквивалентным скаловскому ::
    map fun (head:tail) = fun head : map fun tail

Аналогично для SML или Erlang. Scala такой возможности лишена. Поэтому
кортежи можно использовать для группировки и последующего сопоставления
с образцом. И да, это будет вам стоить производительности (каждый раз
будет создаваться дополнительный объект в памяти):

    // похоже на Haskell, но не то :(
    def map [A, B] (f: A => B, l: List[A]): List[B] = (f, l) match {
        case (f, Nil) => List.empty
        case (f, head::tail) => f(head) :: map(f, tail)
    }

Зачастую бывает необходимо обновить значение в каком-то из элементов
кортежа. Для этого подойдет метод “copy”.

    val dog = ("Rex", 13)
    val olderDog = tuple.copy(_2 = 14)

Об использовании кортежей [в Haskell](tuples_in_haskell) и
[SML](tuples_in_haskell) вы можете прочитать если перейдете по ссылкам

[tuples_in_haskell]: http://stackoverflow.com/questions/15558278/how-to-get-nth-element-from-a-10-tuple-in-haskell
[tuples_in_sml]: http://www.cs.cornell.edu/courses/cs312/2004fa/lectures/lecture3.htm


В реальности, использование кортежей не есть лучший способ представления
координат (во всяком случае в Scala). В Scala для этого лучше использовать
case classы. Потребность в кортежах в основном продиктована наличием
универсальных библиотек, для случаев когда требуется свернуть составную запись
в обобщенном виде. Например `zip` или `groupBy`. Так что если вы хотите
использовать кортежи, используйте их только в случае написания обобщенных
алгоритмов. Во всех остальных случаях лучше иметь старый добрый case class.


## В заключение
В этой статье я попытался (а уж получилось ли, не мне судить) рассказать вам
об основных функциональных идиомах Scala и провести ряд параллелей с другими
функциональными языками. В следующей статье я расскажу про идиомы связанные с
ООП и коллекциями, а также изложу свои мысли касательно инфраструктурных
вопросов терзающих многих начинающих разработчиков. Очень надеюсь что эта
статья вам понравилась. Спасибо за внимание, и до скорой встречи.

