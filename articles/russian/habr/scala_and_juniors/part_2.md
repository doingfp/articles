**Часть 2. Не пойми какая**

В этой статье мы продолжим знакомство с ошибками которые делают начинающие
скалисты и обязательно их повторим, и если что-то можно сделать совсем
омерзительно, то обязательно воспользуемся сей прекрасной возможностью и
сделаем еще гаже. Так же я поделюсь своими взглядами на инструментарий и
попробую разжечь "Holly war".

<cut text="Let's get it started →">


**Структура цикла**

 - [Часть 1. Функциональная](https://habrahabr.ru/post/323706/)
 - [Часть 2. Эта](#)


Собрать и структурировать первую часть было намного проще. Мне даже не
приходилось так долго кропотливо и старательно думать. Думать я вообще не очень
люблю (именно поэтому предпочитаю Java, Scala), однако задуматься пришлось.
Здесь вы найдете заметки посвященные ООП, инструментарию и другим мелочам.
Предлагаю начать с того что меня больше всего раздражает:


## Очень.длинные.выражения.чтоб.на.одну.строчку.хотя.можно.и.перенести()
Я называю их поездами в виду того, что в мире Java поезда имеют символическое
значение. В Scala практически все является выражением, и даже если что-то
возвращает `Unit` вы всегда может получить на выходе ваш `()`. После
длительного программирования на языках где превалируют утверждения (statements),
у многих из нас (я не являюсь исключением), превалирует желание запихнуть все в
одно выражение, сделав длинный-длинный паровозик. Вот вам пример, который я
нагло утащил из Effective Scala:

    val votes = Seq(("scala", 1),
                    ("java", 4),
                    ("scala", 10),
                    ("scala", 1),
                    ("python", 10))

Большой и длинный паровозик:

    // Все понятно? легко читается?
    val orderedVotes = votes
      .groupBy(_._1)
      .map { case (which, counts) =>
        (which, counts.foldLeft(0)(_ + _._2))
      }.toSeq
      .sortBy(_._2)
      .reverse

Выражение разбито на составляющие:

    val votesByLang =
      votes groupBy { case (lang, _) => lang }

    val sumByLang =
      votesByLang map { case (lang, counts) =>

    val countsOnly = counts map { case (_, count) => count }
      (lang, countsOnly.sum)
    }

    val orderedVotes = sumByLang.toSeq
      .sortBy { case (_, count) => count }
      .reverse

Активное применение "паровозики" нашли в Apache Spark. Пожалуйста, не
используйте их даже там. Читать сложно и тошно.


## Неинициализируемые значения
Scala поддерживает неинициализированные значения. Эта функциональность может вам
пригодиться при создании beans. Рассмотрим на следующий пример на Java:

    class MyClass {
        // По-умолчанию, любой наследник Object инциализируется в ноль.
        // Примитивные типы инициализируются со своими значениями по-умолчанию.
        String uninitialized;
    }

То же самое можно проделать и в Scala:

    class {
      // синтаксис с нижним подчеркиванием говорит Scala, что
      // данное поле не будет инциализированно.
      var uninitialized: String = _
    }

Пожалуйста, **не делайте этого**. Инициализируйте значения везде, где можете.
Используйте подобную функциональность, только если используемый вами фреймворк
или библиотека яростно на этом настаивают. При неаккуратном использовании вы
можете получить тонны `NullPointerException`. Однако знать об этой функции
следует, однажды подобное знание сэкономит время. Если вы хотите отложить
инициализацию, используйте ключевое слово `lazy`.

## Не используйте null

  - Всегда инициализируйте значения
  - Оборачивайте `Nullable` которые могут прийти из вне в `Option`
  - Используйте Option
  - Видите null -- исправляете, пока ваши коллеги не завезли
    *специально предназначенный для борьбы с NPE язык*.


## Перегрузки
В Scala существует возможность перегрузки конструкторов для классов. И это —
не лучший способ решить проблему. Скажу больше, это — *не идиоматичный* способ
решения проблемы. Если говорить о практике, эта функция полезна, если вы
используете Java-reflection и ваш Scala-код вызывается из Java или вам
необходимо такое поведение (а почему бы в таком случае не сделать Builder)?
В остальных случаях лучшая стратегия — создание объекта-компаньона и определение
в нем нескольких методов `apply`.
Наиболее примечательны случаи перегрузки конструкторов из-за незнания о
[параметрах по-умолчанию](http://docs.scala-lang.org/tutorials/tour/default-parameter-values.html)
(default parameters).

Совсем недавно, я стал свидетелем следующего безобразия:

    // Все включено!
    case class Monster (pos: Position, health: Int, weapon: Weapon) {
      def this(pos: Position) = this(pos, 100, new Claws)
      def this(pos: Position, weapon: Weapon) = this(pos, 100, weapon)
    }

Ларчик открывается проще:

    case class Monster(
      pos: Position,
      health: Short = 100,
      weapon: Weapon = new Claws
    )

Хотите наградить вашего монстра базукой? Не проблема:

    val aMonster = Monster(Position(300, 300, 20), weapon = new Bazooka)

Мы сделали мир лучше, монстра миролюбивее, и перестали перегружать все что
движется. Миролюбивее? Определенно. Ведь базука, это еще и музыкальный
инструмент.

<img style="width: 300px; float:left;"
src="https://habrastorage.org/files/da7/8c8/61e/da78c861e02d4cb6b190c93768e734a3.jpg"/>

Аналогично перегружаются и методы

### Перегрузка операторов

Не перегружайте операторы, если вы не
TODO:


> Безусловно, после того как вы многократно перегрузите конструкторы вам,
> для довершения картины захочется налепить геттеров и сеттеров.


## О геттерах и сеттерах
Scala предоставляет отличное взаимодействие с Java. Она также способна
облегчить вам жизнь при дизайне так называемых Beans. Если вы не знакомы с
Java или концепцией Beans, возможно, вам следует с ней
[ознакомиться](https://en.wikipedia.org/wiki/JavaBeans).

Слышали ли вы о [Project Lombok](https://projectlombok.org/)? В стандартной
библиотеке Scala имеется схожий механизм. Он именуется `BeanProperty`. Все, что
вам нужно, — создать bean и добавить аннотацию `BeanProperty` к каждому полю,
для которого хотите создать getter или setter.

> Для того чтобы получить `isProperty` для переменных булева типа
> следует добавить `scala.beans.BooleanBeanProperty` в вашу область видимости.

Аннотацию `@BeanProperty` можно так же использовать и для полей класса:

    import scala.beans.{BooleanBeanProperty, BeanProperty}

    class MotherInLaw {
      // По закону, она может сменить имя:
      @BeanProperty var name = "Megaera"

      // Они имеют свойство плодиться
      @BeanProperty var numberOfCatsSheHas = 0

      // Но некоторые вещи не меняются
      @BooleanBeanProperty val jealous = true
    }

Для case class-ов тоже работает:

    import scala.beans.BeanProperty

    case class Dino(@BeanProperty name: String,
                    @BeanProperty var age: Int)

Поиграем с нашим динозавром:

    // Начнем с того, что он не так стар как вы думаете
    val barney = Dino("Barney", 29)

    barney.setAge(30)

    barney.getAge
    // res4: Int = 30

    barney.getName
    // res14: String = Barney

В виду того, что мы не сделали name переменной, при попытке использовать
сеттер, мы получим следующее:

    barney.setName
    <console>:15: error: value setName is not a member of Dino
         barney.setName


## Кстати о case классах
Если вы хотите убедить неофита в преимуществах Scala, вы знаете с чего начать.
Появление case class-ов это прорыв для JVM платформы. В чем же их основное
преимущество? Правильно, в их неизменяемости (immutability), а также наличию
`equals`, `toString` и `hashCode`. Однако, зачастую можно встретить подобное,
там где без этого можно было бы обойтись:

    case class Person(var name: String, var age: Int)

> иногда таки var приходится делать, если вы, например имитируете beans,
> как это продемонстрировано примером выше

Зачастую, подобное бывает когда глубокий джуниор не понимает что такое
имутабельность. С разработчиками уровнем повыше, не менее интересно. Они
прекрасно осознают что делают:

    case class Person (name: String, age: Int) {
      def updatedAge(newAge: Int) = Person(name, newAge)
      def updatedName(newName: String) = Person(newName, age)
    }

Однако про метод `copy` знают не все. Это норма. Подобное мне доводилось
наблюдать не раз, чего уж там, в свое время я сам так хулиганил. Работает `copy`
аналогично своему тезке, который определен для кортежей:

    // обновили возраст, получили новый инстанс
    person.copy(age = 32)


## О размерах case class-ов
Иногда case class-ы имеют свойство раздуваться до 15-20 полей. До появления
Scala 2.11 этот процесс хоть как-то ограничивался 22 элементами. Но сейчас,
ваши руки развязаны:

    case class AlphabetStat (
      a: Int, b: Int,
      c: Int, d: Int,
      e: Int, f: Int,
      g: Int, h: Int,
      i: Int, j: Int,
      k: Int, l: Int,
      m: Int, n: Int,
      o: Int, p: Int,
      q: Int, r: Int,
      s: Int, t: Int,
      u: Int, v: Int,
      w: Int, x: Int,
      y: Int, z: Int
    )

> Хорошо, я вам наврал: ваши руки конечно стали свободнее,
> однако ограничения JVM никто не отменял

Большие case классы это плохо. Это очень плохо. Бывают ситуации когда этому
есть оправдание: предметная область в которой вы работаете не допускает
агрегации, и структура представляется плоской; вы имеете API спроектированный
глубокими идиотами, которые сидят на сильнодействующих транквилизаторах.

И знаете, чаще всего приходится иметь дело со вторым вариантом. Хочется чтобы
case классы легко и непринужденно укладывались на API. И я вас пойму если так.

Но я перечислил только уважительные оправдания монструозности ваших case
классов. Есть и наиболее очевидная: для того чтобы обновить вложенное поле
глубоко запрятанного вглубь вложенных классов, приходится очень сильно
помучиться. Каждый case класс надо старательно разобрать, подменить значение
и собрать. И от этого недуга есть средство: вы можете использовать
линзы (lenses).

Почему линзы называются линзами? Потому что они способны сфокусироваться на
главном. Вы фокусируете линзу на определенную часть структуры, и получаете ее,
вместе с возможностью ее (структуру) обновить. Для начала объявим наши case
классы:

    case class Address(street: String,
                       city: String,
                       postcode: String)

    case class Person(name: String, age: Int, address: Address)

А теперь населим их данными:

    val person = Person("Joe Grey", 37,
                        Address("Southover Street",
                                "Brighton", "BN2 9UA"))

Создаем линзу для улицы (предположим что наш персонаж захотел переехать):

    import shapeless._

    val streetLens = lens[Person].address.street

Читаем поле (прошу заметить что целочисленный тип будет выведен автоматически):

    val street = streetLens.get(person)
    // "Southover Street"

Обновляем значение поля:

    val person1 = streetLens.set(person)("Montpelier Road")
    // person1.address.street == "Montpelier Road"

> Пример был нагло украден из [отсюда](https://github.com/milessabin/shapeless/blob/master/examples/src/main/scala/shapeless/examples/optics.scala) Shapeless

Аналогичную операцию вы можете совершить и над адресом. Как видите, это
достаточно просто. К сожалению, а может быть и к счастью, Scala не
имеет встроенных линз. Поэтому, вам придется использовать стороннюю
библиотеку. Я бы рекомендовал вам использовать `shapeless`. Собственно,
приведенный выше пример, был написан с помощью этой весьма доступной для
обывателя библиотеки.

Существует множество других реализаций для линз, если хотите, вы можете
использовать
[scalaz](http://eed3si9n.com/learning-scalaz/Lens.html),
[monocle](https://github.com/julien-truffaut/Monocle).
Последняя предоставляет более продвинутые механизмы использования оптики, и я
бы рекомендовал ее к дальнейшему использованию.

К сожалению, для того чтобы описать и объяснить механизм действия линз может
потребоваться отдельная статья, поэтому считаю что вышеизложенной информации
достаточно для того чтобы начать собственное исследование оптических систем.


## Переизобретение enumов
Берем опытного Java разработчика и сажаем его на Scala. Не проходит и пары
дней, и он отчаянно начинает искать enum-ы. Не находит их, и расстраивается.
В Scala нет ключевого слова `enum` или даже `enumeration`.
Далее есть два варианта событий: или он нагуглит идиоматичное решение, или
начнет переизобретать свои перечисления. Часто лень побеждает, и мы имеем вот
это:

    object Weekdays {
      val MONDAY = 0
      // догадайтесь что будет дальше...
    }

А дальше то что? А вот что:

    if (weekday == Weekday.Friday) {
       stop(wearing, Tie)
    }

Что не так? В Scala есть идиоматичный способ создания перечислений, именуется
он ADT (Algebraic Data Types), по-русски *алгебраические типы данных*.
Используется, например в Haskell. Вот как он выглядит:

    sealed trait TrafficLight
    case object Green extends TrafficLight
    case object Yellow extends TrafficLight
    case object Red extends TrafficLight
    case object Broken extends TrafficLight

Многословно, самодельное перечисление конечно был короче. Зачем столько писать?
Давайте объявим следующую функцию:

    def tellWhatTheLightIs(tl: TrafficLight): Unit = tl match {
      case Red => println("No cars go!")
      case Green => println("Don't stop me now!")
      case Yellow => println("Ooohhh you better stop!")
    }

И получим:

    warning: match may not be exhaustive.
    It would fail on the following input: Broken
           def tellWhatTheLightIs(tl: TrafficLight): Unit = tl match {
                                                            ^
    tellWhatTheLightIs: (tl: TrafficLight)Unit

Мы получаем перечисление, свободное от привязки к каким либо константам, а так
же проверку на исчерпываемость при сопоставлении с образцом. И да, если вы
используете "enumы для бедных", как их обозвал один мой небезызвестный коллега,
используйте сопоставление с образцом. Это наиболее идиоматичный способ.
Стоит заметить, об этом упоминается в начале замечательной книги [Programming in
Scala](https://www.scala-lang.org/documentation/books.html), написанной
Мартином Одерски. Не каждая птица долетит до середины Днепра, так же как и не
каждый скалист прочтет *Magnum Opus*.

Неплохо про алгебраические типы данных рассказано, как ни странно, в
[Википедии](https://en.wikipedia.org/wiki/Algebraic_data_type). Касательно
Scala, есть достаточно доступный [пост](https://gleichmann.wordpress.com/2011/01/30/functional-scala-algebraic-datatypes-enumerated-types)
и [презентация](http://tpolecat.github.io/presentations/algebraic_types.html),
которая, возможно, покажется вам интересной.


## Избегайте логических аргументов в сигнатурах функций
Признайтесь, вы писали методы, которые в качестве аргумента принимают Boolean?
В случае с Java ситуация вообще катастрофичная:

    PrettyPrinter.print(text, 1, true)

Что может означать 1. Ладно, доверимся интуиции и предположим что это количество
копий. А за что отвечает true? Это может быть что угодно. Ладно, схожу в
исходники посмотрю что это.

В Scala вы можете использовать ADT вместо логических типов:

    def print(text: String, copies: Int, wrapWords: WordWrap)

Даже если вам достался в наследство код требующий логических аргументов, вы
можете использовать параметры по умолчанию.

    PrettyPrinter.print(text, copies = 1, WordWrap.Enabled)


## О выражениях
### Не используйте return
В Scala почти все является выражением. Исключение составляет `return`, который
не следует использовать не при каких обстоятельствах. Это не опциональное
слово. Это конструкция которая меняет семантику программы. Подробнее об этом
можете прочитать [здесь](https://tpolecat.github.io/2014/05/09/return.html)

### Не используйте метки
В Scala есть метки, представляете себе. К счастью они не являются частью языка,
и реализованы при помощи бросания (отлова) исключений (об исключениях мы
поговорм далее в этой статье
TODO:


## Об исключениях
TODO:



## Не используйте структурные типы
TODO: Рассказать о том почему они так плохи


## О циклах

### Не используйте циклы
Используйте хвостовую рекурсию, зачастую она не медленнее чем цикл

### Не используйте for-loop


### Генераторы списков, не циклы


TODO: TYPES!


## Работа над ошибками
TODO: exceptions
Failure handling:
  Try Either and Validation
  todo:

    val first = Try(Console.readLine("enter a number"))
    val second = Try(Console.readLIne("another number"))

    val sum: Try[Int] = for { f <- first; s <- second } yield f.toInt + s.toInt

  todo: add validation monad

TODO operator notation







## О генераторах списков
Главное, что вам следует знать про генераторы списков, или, как их еще
Называют, “for comprehensions”, что основное их предназначение — не в
реализации циклов.

Эту синтаксическую конструкцию можно использовать не только для итерации по
элементам коллекций и фильтрации. Более того, использование подобной конструкции
для итерации будет достаточно дорогостоящей процедурой. Цикл `while` или
использование хвостовой рекурсии — намного дешевле.

“For comprehension” представляет собой синтаксический сахар для методов `map`,
`flatMap` и `withFilter`. Ключевое слово `yield` используется для последующей
агрегации значений в результирующей структуре.

Замечательнейшее [видео](fors-video), в котором подробно рассказывается
все, что вы хотели знать про генераторы списков.

[fors-video]: https://www.youtube.com/watch?v=WDaw2yXAa50

> И пожалуйста, не называйте итерационные переменные i, j, k. При правильном
> использовании `for`, вам не придется использовать эти несчастные переменные


## ? extends App
Знаете что не так с этим кодом:

    object Main extends App {
      Console.println("Hello World: " + (args mkString ", "))
    }

Конкретно с этим примером "все так". Все будет хорошо и прекрасно работать,
пока вы не усложните код достаточно, чтобы встретиться с непредсказуемым
поведением. И виной тому один трейт из стандартной библиотеки. Он называется
`DelayedInit`. Прочитать о нем вы можете [здесь](delayed-init).
Трейт `App`, который вам предлагается расширить в большинстве руководств,
расширяет трейт `DelayedInit`. Подробнее об `App` в [документации](app-doc).

> It should be noted that this trait is implemented using the DelayedInit
> functionality, which means that fields of the object will not have been
> initialized before the main method has been executed.

По-русски:

> Следует учесть, что данный трейт реализован с использованием функциональности
> DelayedInit, что означает то что поля объекта не будут проинициализированны
> до выполнения main метода.

В будущем это обещают исправить:

> Future versions of this trait will no longer extend DelayedInit.

Плохо ли использовать `App`? В сложных многопоточных приложениях я бы не стал
этого делать. А если вы пишете "Hello world"? Почему бы нет. Я стараюсь лишний
раз не связываться и использую традиционный `main` метод.

[app-doc]: http://www.scala-lang.org/api/current/scala/App.html
[delayed-init]: http://www.scala-lang.org/api/current/scala/DelayedInit.html




## Неэффективное использование коллекций
Очень часто, в коде можно увидеть эмуляцию функций стандартной библиотеки
Scala. Приведу простой пример:

    tvs.filter(tv.displaySize == 50.inches).headOption

Тоже самое, только короче:

    tvs.find(tv.displaySize == 50.inches)

Подобный "антипаттерны" тоже не редкость :

    list.size = 0  // плохо
    list.isEmpty   // ok

    !list.empty    // плохо
    list.nonEmpty  // ok

    tvs.filter(tv => !tv.supportsSkype)    // плохо
    tvs.filterNot(tv => tv.supportsSkype)  // ok

> Конечно, если вы используете IntelliJ IDEA, она вам обязательно подскажет
> наиболее эффективную комбинацию методов. Scala IDE, насколько мне известно,
> так не умеет.

О неэффективном использовании библиотеки коллекций Scala можно рассказывать
сколь угодно долго. И это уже очень не плохо сделал Павел Фатин в своей статье
[Scala collections Tips and Tricks](https://pavelfatin.com/scala-collections-tips-and-tricks).


## Хозяйственные вопросы
### Установка и настройка
А начнем мы с потугов поставить несчастную Скалу и подключить ее в проект.
Как это выглядит у обычных людей? Для начала надо скачать JDK, если вы конечно
не джавист, кложурист (или еще какой маргинал). Обязательно прописать `PATH` к
`javac`, или убедиться в том что он прописан, поставить *вашу любимую IDE*,
скачать скалу, прописать ее, скачать Sbt прописать его. Ничего не забыли?
Зачастую нужно иметь несколько разных версий Scala на вашем компьютере. Какой
кошмар! Самое время паниковать! Или использовать [SdkMan!](http://sdkman.io/install.html).
Если в двух словах, этот инструмент позволяет устанавливать различные системы
сборки и jvm-языки, и управлять их версиями. Так что применителен он не только
к Scala.

## Муки выбора IDE
Каждый раз я слышу вопрос: "А какую IDE для Scala использовать?". И знаете
какой ответ я даю? Все и сразу. Поставьте ScalaIDE, поставьте IDEA, установите
ENISME. И выберите то что вам подходит. Для работы я использую IntelliJ IDEA.
Для личных проектов vim/emacs, ScalaIDE я использую, когда IDEA снесет крышу.
Поверьте, и такое бывает. Но, как показывает практика, большинство
разработчиков остаются с IntelliJ IDEA: мышки плакали, но продолжали есть
кактус. И для многих компаний/проектов она является стандартом де-факто. В
любом случае мой совет -- ставить все. И использовать конкретные инструменты,
для конкретных задач.

IntelliJ IDEA Community Edition прекрасно поддерживает и Scala, и Dotty. И
я рекомендую использовать ее. Вы также можете воспользоваться ScalaIDE
или ENSIME Никто вам не запрещает вручную настроить Vim.

> Если все-таки вы собираетесь устанавливать Scala-IDE, проще всего сделать
> это, скачав готовую сборку IDE (нажав кнопку Download IDE) или пройдя по
> ссылке ниже. Вы также можете установить ее как плагин для Eclipse, конечно,
> если вы знаете, что делаете ☺.


## Плюсы и минусы выбора конкретной IDE
Выбирая IntelliJ IDEA, вы получаете лучшую на данный момент поддержку Scala,
огромное количество плагинов и достаточно высокую скорость работы.
Минус — если вам потребуется использовать Play framework, придется приобрести
полную версию продукта, что стоит денег. Хотя при невысоком уровне дискомфорта
можно по-прежнему обходиться Community Edition. Если у вас есть полная версия
(Ultimate), думаю, для вас выбор очевиден.

Выбирая Scala IDE, вы получаете Eclipse с отличной официальной поддержкой
Scala. Плюсы: Eclipse как свободная платформа с огромным количеством
доступных плагинов — платных и бесплатных. Вы получаете официальную
поддержку (что немаловажно). Также Play framework для Scala IDE будет работать
"из коробки". Вы его ставите и пользуетесь.

ENSIME — для тех, кто любит Vim или Emacs. Очень хорошо сделана поддержка для
Scala, и поддержку вашего любимого текстового редактора можно выделить в
качестве основного плюса. Не добавить, не убавить.




## Список литературы
В заключении этой статьи я бы порекомендовать материалов, которые я нахожу
полезными для изучения.

### Книги
[Книга](https://www.amazon.com/Programming-Scala-Updated-2-12/dp/0981531687),
которую должен прочесть каждый Scala разработчик. К сожалению, не всем хватает
терпения, прочесть эту книгу до конца.

### Официальная документация
[Руководство по стилю Scala](http://docs.scala-lang.org/style/)

### Статьи
[Effective Scala](http://twitter.github.io/effectivescala/).
[Scala Collections Tips and Tricks Павла Фатина](https://pavelfatin.com/scala-collections-tips-and-tricks/)

### Видео
 - [Scala with style](https://www.youtube.com/watch?v=kkTFx3-duc8) —
 - [Martin Odersky, Scala -- the Simple Parts](https://www.youtube.com/watch?v=ecekSCX3B4Q)
 - [Daniel Spiewak, May Your Data Ever Be Coherent](https://youtu.be/gVXt1RG_yN0)

[Видео](https://www.youtube.com/watch?v=WDaw2yXAa50), посвященное подробному
разбору, "for comprehensions".




## Благодарности
Спасибо Владу Ледовских за вычитку. Особую благодарность хотел бы выразить
@firegurafiku за вычитку и правку текста, а так же за помощь с разделом
повященным `typedef` первой части статьи. Хочу сказать отдельное спасибо
@primetalk за внесение уточнений в изначальный текст. Большое спасибо @senia,
за найденные неточности.
Спасибо EDU отделу @DataArt, а так же всем тем кто проходя наши курсы по
Scala давал повод для написания данной статьи.
Если вас я здесь упомянуть забыл, вам тоже спасибо.
Спасибо вам, уважаемые читатели, что дочитали до конца.

