**Часть 2. Ошибки, рекомендации и пожелания**

TODO: Добавить паравозики don't pack to much into a single expression

TODO: Recurse if you can. As fast as a loop

TODO: Узнать у Антона умеет ли ScalaIde трекать неоптимальные вызовы
коллекций

В этой статье мы продолжим знакомство с ошибками которые делают начинающие
скалисты: вы обязательно встретите раздел об изобретении велосипедов, не
идиоматичную перегрузку конструкторов, а также подбор моих скромных рекомендаций
касающихся хозяйственной части.

**Структура цикла**

 - [Часть 1](#)
 - [Часть 2](#)

<cut text="Читать про то что осталось →">

## О генераторах списков
Главное, что вам следует знать про генераторы списков, или, как их еще
Называют, “for comprehensions”, что основное их предназначение — не в
реализации циклов.

Эту синтаксическую конструкцию можно использовать не только для итерации по
элементам коллекций и фильтрации. Более того, использование подобной конструкции
для итерации будет достаточно дорогостоящей процедурой. Цикл `while` или
использование хвостовой рекурсии — намного дешевле.

“For comprehension” представляет собой синтаксический сахар для методов `map`,
`flatMap` и `withFilter`. Ключевое слово `yield` используется для последующей
агрегации значений в результирующей структуре.

Замечательнейшее [видео](fors-video), в котором подробно рассказывается
все, что вы хотели знать про генераторы списков.

[fors-video]: https://www.youtube.com/watch?v=WDaw2yXAa50

> И пожалуйста, не называйте итерационные переменные i, j, k. При правильном
> использовании `for`, вам не придется использовать эти несчастные переменные


## ? extends App
Знаете что не так с этим кодом:

    object Main extends App {
      Console.println("Hello World: " + (args mkString ", "))
    }

Конкретно с этим примером "все так". Все будет хорошо и прекрасно работать,
пока вы не усложните код достаточно, чтобы встретиться с непредсказуемым
поведением. И виной тому один трейт из стандартной библиотеки. Он называется
`DelayedInit`. Прочитать о нем вы можете [здесь](delayed-init).
Трейт `App`, который вам предлагается расширить в большинстве руководств,
расширяет трейт `DelayedInit`. Подробнее об `App` в [документации](app-doc).

> It should be noted that this trait is implemented using the DelayedInit
> functionality, which means that fields of the object will not have been
> initialized before the main method has been executed.

По-русски:

> Следует учесть, что данный трейт реализован с использованием функциональности
> DelayedInit, что означает то что поля объекта не будут проинициализированны
> до выполнения main метода.

В будущем это обещают исправить:

> Future versions of this trait will no longer extend DelayedInit.

Плохо ли использовать `App`? В сложных многопоточных приложениях я бы не стал
этого делать. А если вы пишете "Hello world"? Почему бы нет. Я стараюсь лишний
раз не связываться и использую традиционный `main` метод.

[app-doc]: http://www.scala-lang.org/api/current/scala/App.html
[delayed-init]: http://www.scala-lang.org/api/current/scala/DelayedInit.html


## Перегрузки
В Scala существует возможность перегрузки конструкторов для классов. И это —
не лучший способ решить проблему. Скажу больше, это — *не идиоматичный* способ
решения проблемы. Если говорить о практике, эта функция полезна, если ваш
Scala-код вызывается из Java, и вам необходимо такое поведение (а почему бы в
таком случае не сделать Builder)? В остальных случаях лучшая стратегия —
создание companion-object и определение в нем нескольких методов `apply`.
Наиболее примечательны случаи перегрузки конструкторов из-за незнания о
[параметрах по-умолчанию](default-parameters) (default parameters).

[default-parameters](http://docs.scala-lang.org/tutorials/tour/default-parameter-values.html)

Совсем недавно, я стал свидетелем следующего безобразия:

    // Все включено!
    case class Monster (pos: Position, health: Int, weapon: Weapon) {
      def this(pos: Position) = this(pos, 100, new Claws)
      def this(pos: Position, weapon: Weapon) = this(pos, 100, weapon)
    }

Ларчик открывается проще:

    case class Monster(
      pos: Position,
      health: Short = 100,
      weapon: Weapon = new Claws
    )

Хотите наградить вашего монстра базукой? Не проблема:

    val dima = Monster(Position(300, 300, 20), weapon = new Bazooka)

Мы сделали мир лучше, монстра миролюбивее, и перестали перегружать все что
движется. Миролюбивее? Определенно. Ведь базука, это еще и музыкальный
инструмент:

<img src="https://habrastorage.org/files/da7/8c8/61e/da78c861e02d4cb6b190c93768e734a3.jpg"/>


## Scala Beans
Scala предоставляет отличное взаимодействие с Java. Она также способна
облегчить вам жизнь при дизайне так называемых Beans. Если вы не знакомы с
Java или концепцией Beans, советуем [ознакомиться](java-beans).

В Scala имеется механизм, схожий с [Project Lombok](project-lombok). Он
называется `BeanProperty` и является частью стандартной библиотеки. Все, что
вам нужно, — создать bean и добавить аннотацию `BeanProperty` к каждому полю,
для которого хотите создать getter или setter. [Здесь](bean-property-alvin) вы
можете подробнее прочитать об использовании данного свойства. Документацию к
`BeanProperty` вы можете найти [здесь](bean-property-doc).

Если вы хотите создать getter и setter для переменной логического типа,
[данный класс](bool-prop) может вам в этом помочь: на выходе вы получите метод
вида `isProperty`.

[java-beans]: https://en.wikipedia.org/wiki/JavaBeans
[project-lombok]: https://projectlombok.org/
[bean-property-doc]: https://www.scala-lang.org/api/2.12.0/scala/beans/BeanProperty.html
[bean-property-alvin]: http://alvinalexander.com/scala/how-to-create-scala-javabeans-beanproperty-java-libraries
[bean-property-illustrated]: https://daily-scala.blogspot.ru/2009/09/beanproperties.html
[bool-prop]: http://www.scala-lang.org/api/2.12.0/scala/beans/BooleanBeanProperty.html


## О case классах
Появление case classов в Scala это прорыв для индустриальных языков (коим Scala
к счастью является). В чем их основное преимущество? Правильно, в их
неизменяемости иммутабельности. И многие программисты это осознают:

    case class Person (name: String, age: Int) {
      def withUpdatedAge(newAge: Int) = Person(name, newAge)
      def withUpdatedName(newName: String) = Person(newName, age)
    }

Каждый `case class` поддерживает метод `copy`

## О Линзах

TODO:


## Неэффективное использование коллекций

TODO:


## Переизобретение enumов
Берем опытного Java разработчика и сажаем его на Scala. Не проходит и пары
дней, и он отчаянно начинает искать enumы. Не находит их, и расстраивается.
В Scala нет ключевого слова `enum` или даже `enumeration`.
Далее есть два варианта событий: или он нагуглит идиоматичное решение, или
начнет переизобретать свои перечисления. Часто лень побеждает, и мы имеем вот
это:

    object Weekdays {
      val MONDAY = 0
      // догадайтесь что будет дальше...
    }

А дальше то что? А вот что:

    if (weekday == Weekday.Friday) {
       stop(wearing, Tie)
    }

Что не так? В Scala есть идиоматичный способ создания перечислений, именуется
он ADT (Algebraic Data Types), по-русски *алгебраические типы данных*.
Используется, например в Haskell. Вот как он выглядит:

    sealed trait TrafficLight
    case object Green extends TrafficLight
    case object Yellow extends TrafficLight
    case object Red extends TrafficLight
    case object Broken extends TrafficLight

Многословно, самодельное перечисление конечно был короче. Зачем столько писать?
Давайте объявим следующую функцию:

    def tellWhatTheLightIs(tl: TrafficLight): Unit = tl match {
      case Red => println("No cars go!")
      case Green => println("Don't stop me now!")
      case Yellow => println("Ooohhh you better stop!")
    }

И получим:

    warning: match may not be exhaustive.
    It would fail on the following input: Broken
           def tellWhatTheLightIs(tl: TrafficLight): Unit = tl match {
                                                            ^
    tellWhatTheLightIs: (tl: TrafficLight)Unit

Мы получаем перечисление, свободное от привязки к каким либо константам, а так
же проверку на исчерпываемость при сопоставлении с образцом. И да, если вы
используете "enumы для бедных", как их обозвал один мой небезызвестный коллега,
используйте сопоставление с образцом. Это наиболее идиоматичный способ.
Стоит заметить, об этом упоминается в начале замечательной книги [Programming in
Scala](magnum-opus), написанной Мартином Одерски. Не каждая птица долетит до
середины Днепра, так же как и не каждый скалист прочтет *Magnum Opus*.

[magnum-opus]: https://www.scala-lang.org/documentation/books.html

Неплохо про алгебраические типы данных рассказано, как ни странно, в
[Википедии](adt-wiki). Касательно Scala, есть достаточно доступный
[пост](scala-adt) и [презентация](scala-adt-2), которая, возможно,
покажется вам интересной.

[adt-wiki]: https://en.wikipedia.org/wiki/Algebraic_data_type
[scala-adt]: https://gleichmann.wordpress.com/2011/01/30/functional-scala-algebraic-datatypes-enumerated-types/
[scala-adt-2]: http://tpolecat.github.io/presentations/algebraic_types.html#18


## Неинициализируемые значения
Scala поддерживает неинициализированные значения. Эта функциональность как раз
потребуется вам при создании beans. Рассмотрим на следующий пример на Java:

    class MyClass {
        // По-умолчанию, любой наследник Object инциализируется в ноль.
        // Примитивные типы инициализируются со своими значениями по-умолчанию.
        String uninitialized;
    }

То же самое можно проделать и в Scala:

    class {
      // синтаксис с нижним подчеркиванием говорит Scala, что
      // данное поле не будет инциализированно.
      var uninitialized: String = _
    }

Пожалуйста, **не делайте этого**. Инициализируйте значения везде, где можете.
Используйте подобную функциональность, только если используемый вами фреймворк
или библиотека яростно на этом настаивают. При неаккуратном использовании вы
можете получить тонны `NullPointerException`. Однако знать об этой функции
следует, однажды подобное знание сэкономит время. Если вы хотите отложить
инициализацию, используйте ключевое слово `lazy`.


## Хозяйственные вопросы
### Установка и настройка
А начнем мы с потугов поставить несчастную Скалу и подключить ее в проект.
Как это выглядит у обычных людей? Для начала надо скачать JDK, если вы конечно
не джавист, кложурист (или еще какой маргинал). Обязательно прописать `PATH` к
`javac`, или убедиться в том что он прописан, поставить *вашу любимую IDE*,
скачать скалу, прописать ее, скачать Sbt прописать его. Ничего не забыли?
Зачастую нужно иметь несколько разных версий Scala на вашем компьютере. Какой
кошмар! Самое время паниковать! Или использовать [SdkMan!](sdkman).
Если в двух словах, этот инструмент позволяет устанавливать различные системы
сборки и jvm-языки, и управлять их версиями. Так что применителен он не только
к Scala.

[sdkman]: http://sdkman.io/install.html


## Муки выбора IDE
Каждый раз я слышу вопрос: "А какую IDE для Scala использовать?". И знаете
какой ответ я даю? Все и сразу. Поставьте ScalaIDE, поставьте IDEA, установите
ENISME. И выберите то что вам подходит. Для работы я использую IntelliJ IDEA.
Для личных проектов vim/emacs, ScalaIDE я использую, когда IDEA снесет крышу.
Поверьте, и такое бывает. Но, как показывает практика, большинство
разработчиков остаются с IntelliJ IDEA: мышки плакали, но продолжали есть
кактус. И для многих компаний/проектов она является стандартом де-факто. В
любом случае мой совет -- ставить все. И использовать конкретные инструменты,
для конкретных задач.

IntelliJ IDEA Community Edition прекрасно поддерживает и Scala, и Dotty. И
я рекомендую использовать ее. Вы также можете воспользоваться ScalaIDE
или ENSIME Никто вам не запрещает вручную настроить Vim.

> Если все-таки вы собираетесь устанавливать Scala-IDE, проще всего сделать
> это, скачав готовую сборку IDE (нажав кнопку Download IDE) или пройдя по
> ссылке ниже. Вы также можете установить ее как плагин для Eclipse, конечно,
> если вы знаете, что делаете ☺.


## Плюсы и минусы выбора конкретной IDE
Выбирая IntelliJ IDEA, вы получаете лучшую на данный момент поддержку Scala,
огромное количество плагинов и достаточно высокую скорость работы.
Минус — если вам потребуется использовать Play framework, придется приобрести
полную версию продукта, что стоит денег. Хотя при невысоком уровне дискомфорта
можно по-прежнему обходиться Community Edition. Если у вас есть полная версия
(Ultimate), думаю, для вас выбор очевиден.

Выбирая Scala IDE, вы получаете Eclipse с отличной официальной поддержкой
Scala. Плюсы: Eclipse как свободная платформа с огромным количеством
доступных плагинов — платных и бесплатных. Вы получаете официальную
поддержку (что немаловажно). Также Play framework для Scala IDE будет работать
"из коробки". Вы его ставите и пользуетесь.

ENSIME — для тех, кто любит Vim или Emacs. Очень хорошо сделана поддержка для
Scala, и поддержку вашего любимого текстового редактора можно выделить в
качестве основного плюса. Не добавить, не убавить.


## Список литературы
В заключении этой статьи я бы порекомендовать материалов, которые я нахожу
полезными для изучения.

### Книги
[Книга](https://www.amazon.com/Programming-Scala-Updated-2-12/dp/0981531687),
которую должен прочесть каждый Scala разработчик. К сожалению, не всем хватает
терпения, прочесть эту книгу до конца.

### Статьи документации
, пос вам ознакомиться со статьей
[Effective Scala](http://twitter.github.io/effectivescala/).

### Видео
 - [Scala with style](https://www.youtube.com/watch?v=kkTFx3-duc8) —
 - [Martin Odersky, Scala -- the Simple Parts](https://www.youtube.com/watch?v=ecekSCX3B4Q)

[Видео](https://www.youtube.com/watch?v=WDaw2yXAa50), посвященное подробному
разбору, "for comprehensions".


  TODO: добавить еще литературы
   - Scala with style
   - May your data ever be coherent ???

[effective-scala]:



## Благодарности
Спасибо Владу Ледовских за вычитку. Особую благодарность хотел бы выразить
@firegurafiku за вычитку и правку текста, а так же за помощь с разделом
повященным `typedef`. Хочу сказать отдельное спасибо @primetalk за
внесение уточнений в изначальный текст.

Спасибо EDU отделу @DataArt, а так же всем тем кто проходя наши курсы по
Scala давал повод для написания данной статьи.

Спасибо вам, уважаемые читатели, что дочитали до конца

