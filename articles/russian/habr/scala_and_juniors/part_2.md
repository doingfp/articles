**Часть 2. Не пойми какая**
TODO: не признаваться в том что не очень люблю думать.
TODO: убрать омерзительно и гаже
В этой статье мы продолжим знакомство с ошибками которые делают начинающие
скалисты и обязательно их повторим (а как иначе?), и если что-то можно сделать
совсем омерзительно, то обязательно воспользуемся этой возможностью и
сделаем гаже. В конце статьи я поделюсь своими взглядами на инструментарий и
попробую разжечь "Holly war".

<cut text="Let's get it started →">


**Структура цикла**

 - [Часть 1. Функциональная](https://habrahabr.ru/post/323706/)
 - [Часть 2. Эта](#)


Собрать и структурировать первую часть было намного проще. Мне даже не
приходилось так долго кропотливо и старательно думать. Думать я вообще не очень
люблю (именно поэтому предпочитаю Java, Scala), однако задуматься пришлось.
Здесь вы найдете заметки посвященные ООП, инструментарию и другим мелочам.
Предлагаю начать с того что меня больше всего раздражает:


## Длина выражений
В Scala практически все является выражением, и даже если что-то возвращает
`Unit` вы всегда можете получить на выходе ваш `()`. После длительного
программирования на языках где превалируют утверждения (statements), у многих
из нас (я не являюсь исключением), превалирует желание запихнуть все в одно
выражение, сделав длинный-длинный паровозик. Вот вам
пример который я нагло утащил из Effective Scala:

    val votes = Seq(("scala", 1),
                    ("java", 4),
                    ("scala", 10),
                    ("scala", 1),
                    ("python", 10))

А как вам такой пример? Все понятно? легко читается?

    val orderedVotes = votes
      .groupBy(_._1)
      .map { case (which, counts) =>
        (which, counts.foldLeft(0)(_ + _._2))
      }.toSeq
      .sortBy(_._2)
      .reverse

Он же разбит на именованные составляющие:

    val votesByLang =
      votes groupBy { case (lang, _) => lang }

    val sumByLang =
      votesByLang map { case (lang, counts) =>

    val countsOnly = counts map { case (_, count) => count }
      (lang, countsOnly.sum)
    }

    val orderedVotes = sumByLang.toSeq
      .sortBy { case (_, count) => count }
      .reverse

> Возможно, приведенный выше пример не является достаточно длинным и наглядным,
> я даже поленился его придумать. Но поверье, но мне попадались очень длинные
> конструкции, которые авторы даже не досуживались переносить.

Очень часто в Scala приходят через Spark, а уж используя Spark так и хочется
сцепить побольше "вагончиков" в длинный "поезд". Это сильно бьет по читаемости.

**Поезда и operator notation**
Надеюсь что многим уже известно, что на самом деле `2 + 2` это есть `2.+(2)`
записанная в операторной нотации (operator notation). Благодаря этой
возможности языка у нас нет операторов, а есть именованные методы, и
инструмент позволяющий создавать выразительные DSL (Собственно для этого она и
была добавлена в язык).
Благодаря данной возможности языка, вы сколь угодно долго можете записывать без
точек и скобочек вызовы типа: `object fun arg fun1 arg1`. И эта возможность
поистине крута, если вы используете ее в рамках DSL:

    myList should have length 10

Но в большинстве случаев, операторная нотация в совокупе с длинными выражениями
приносит боль. Да, операции на коллекциях выглядят круче с использованием
данной нотации, но **только** когда они разбиты на именованные составляющие.

**Поезда и postfix notation**
Постфиксные операторы, при определенных условиях, способны причинить боль
парсеру, поэтому в последних релизах Scala, их нужно импортировать явно.
Статайтесь не использовать постфиксную запись, и проектировать ваши DSL так,
чтобы эту запись не приходилось использовать. Сделать это достаточно не сложно.


## Неинициализируемые значения
Scala поддерживает неинициализированные значения. Эта функциональность может вам
пригодиться при создании beans. Рассмотрим на следующий пример на Java:

    class MyClass {
        // По-умолчанию, любой наследник Object инциализируется в null
        // Примитивные типы инициализируются значениями по-умолчанию
        String uninitialized;
    }

То же самое можно проделать и в Scala:

    class {
      // синтаксис с нижним подчеркиванием говорит Scala, что
      // данное поле не будет инциализированно.
      var uninitialized: String = _
    }

Пожалуйста, **не делайте этого**. Инициализируйте значения везде, где можете.
Используйте подобную функциональность, только если используемый вами фреймворк
или библиотека яростно на этом настаивают. При неаккуратном использовании вы
можете получить тонны `NullPointerException`. Однако знать об этой функции
следует: однажды подобное знание сэкономит время. Если вы хотите отложить
инициализацию, используйте ключевое слово `lazy`.

## Не используйте null
  - Всегда инициализируйте значения
  - Оборачивайте `Nullable` которые могут прийти извне в `Option`
  - Используйте `Option`
  - Видите null -- исправляете, пока ваши коллеги не завезли
    *специально предназначенный для борьбы с NPE язык*.


## О перегрузках

**Методы**
В Scala существует возможность перегрузки конструкторов для классов. И это —
не лучший способ решить проблему. Скажу больше, это — *не идиоматичный* способ
решения проблемы. Если говорить о практике, эта функция полезна, если вы
используете Java-reflection и ваш Scala-код вызывается из Java или вам
необходимо такое поведение (а почему бы в таком случае не сделать Builder)?
В остальных случаях лучшая стратегия — создание объекта-компаньона и определение
в нем нескольких методов `apply`.

Наиболее примечательны случаи перегрузки конструкторов из-за незнания о
[параметрах по-умолчанию](http://docs.scala-lang.org/tutorials/tour/default-parameter-values.html)
(default parameters).

Совсем недавно, я стал свидетелем следующего безобразия:

    // Все включено!
    case class Monster (pos: Position, health: Int, weapon: Weapon) {
      def this(pos: Position) = this(pos, 100, new Claws)
      def this(pos: Position, weapon: Weapon) = this(pos, 100, weapon)
    }

Ларчик открывается проще:

    case class Monster(
      pos: Position,
      health: Short = 100,
      weapon: Weapon = new Claws
    )

Хотите наградить вашего монстра базукой? Да, не проблема:

    val aMonster = Monster(Position(300, 300, 20), weapon = new Bazooka)

Мы сделали мир лучше, монстра миролюбивее, и перестали перегружать все что
движется. Миролюбивее? Определенно. Ведь базука, это еще и музыкальный
инструмент (можете спросить об этом википедию).

К сожалению, вместе с конструкторами перегружаются и методы (там где этого
можно было избежать).

**Перегрузка операторов**
Считается достаточно противоречивой фичей Scala, и когда я только-только
погрузился в язык, перегрузка операторов использовалась повсюду. Всеми и везде
где только можно. Сейчас эта фича стала менее популярна. Изначально, перегрузка
операторов была сделана, в первую очередь, для того чтобы иметь возможность
составлять DSL, такие, как в Parboiled или в роутинг для akka-http.

Не перегружайте операторы без надобности, и если считаете что эта надобность
у вас есть, то все-равно не перегружайте.

А если перегружаете (вам нужен DSL или ваша библиотека делает нечто
математическое (или трудновыразимое словами)), обязательно дублируйте текстовым
именем оператора. И думайте о последствиях. Так, Благодаря scalaz оператор `|@|`
([Applicative Builder](http://eed3si9n.com/learning-scalaz/Applicative+Builder.html))
получил имя Maculay Culkin. Можете воспользоваться поиском и угадать почему.

TODO: добавить картинку с этим несчастным пацаном

Безусловно, после того как вы многократно перегрузите конструкторы вам,
для довершения картины захочется налепить геттеров и сеттеров.


## О геттерах и сеттерах
Scala предоставляет отличное взаимодействие с Java. Она также способна
облегчить вам жизнь при дизайне так называемых Beans. Если вы не знакомы с
Java или концепцией Beans, возможно, вам следует с ней
[ознакомиться](https://en.wikipedia.org/wiki/JavaBeans).

Слышали ли вы о [Project Lombok](https://projectlombok.org/)? В стандартной
библиотеке Scala имеется схожий механизм. Он именуется `BeanProperty`. Все, что
вам нужно, — создать bean и добавить аннотацию `BeanProperty` к каждому полю,
для которого хотите создать getter или setter.

> Для того чтобы получить `isProperty` для переменных булева типа
> следует добавить `scala.beans.BooleanBeanProperty` в вашу область видимости.

Аннотацию `@BeanProperty` можно так же использовать и для полей класса:

    import scala.beans.{BooleanBeanProperty, BeanProperty}

    class MotherInLaw {
      // По закону, она может сменить имя:
      @BeanProperty var name = "Megaera"

      // А эти ребята имеют свойство плодиться
      @BeanProperty var numberOfCatsSheHas = 0

      // Но некоторые вещи неизменны
      @BooleanBeanProperty val jealous = true
    }

Для case class-ов тоже работает:

    import scala.beans.BeanProperty

    case class Dino(@BeanProperty name: String,
                    @BeanProperty var age: Int)

Поиграем с нашим динозавром:

    // Начнем с того, что он не так стар как вы думаете
    val barney = Dino("Barney", 29)

    barney.setAge(30)

    barney.getAge
    // res4: Int = 30

    barney.getName
    // res14: String = Barney

В виду того, что мы не сделали name переменной, при попытке использовать
сеттер, мы получим следующее:

    barney.setName
    <console>:15: error: value setName is not a member of Dino
         barney.setName


## Кстати о case классах
Появление case class-ов это прорыв для JVM платформы. В чем же их основное
преимущество? Правильно, в их неизменяемости (immutability), а также наличию
`equals`, `toString` и `hashCode`. Однако, зачастую можно встретить подобное,
там где без этого можно было бы обойтись:

    case class Person(var name: String, var age: Int)

> иногда таки var приходится делать, если вы, например имитируете beans,
> как это продемонстрировано примером выше

Зачастую, подобное бывает когда глубокий джуниор не понимает что такое
имутабельность (или нужно сделать Bean). С разработчиками уровнем повыше,
не менее интересно: они прекрасно осознают что делают:

    case class Person (name: String, age: Int) {
      def updatedAge(newAge: Int) = Person(name, newAge)
      def updatedName(newName: String) = Person(newName, age)
    }

Однако про метод `copy` знают не все. Это норма. Подобное мне доводилось
наблюдать не раз, чего уж там, в свое время я сам так хулиганил. Работает `copy`
аналогично своему тезке, который определен для кортежей:

    // обновили возраст, получили новый инстанс
    person.copy(age = 32)


## О размерах case class-ов
Иногда case class-ы имеют свойство раздуваться до 15-20 полей. До появления
Scala 2.11 этот процесс хоть как-то ограничивался 22 элементами. Но сейчас,
ваши руки развязаны:

    case class AlphabetStat (
      a: Int, b: Int,
      c: Int, d: Int,
      e: Int, f: Int,
      g: Int, h: Int,
      i: Int, j: Int,
      k: Int, l: Int,
      m: Int, n: Int,
      o: Int, p: Int,
      q: Int, r: Int,
      s: Int, t: Int,
      u: Int, v: Int,
      w: Int, x: Int,
      y: Int, z: Int
    )

> Хорошо, я вам наврал: ваши руки конечно стали свободнее,
> однако ограничения JVM никто не отменял

Большие case классы это плохо. Это очень плохо. Бывают ситуации когда этому
есть оправдание: предметная область в которой вы работаете не допускает
агрегации, и структура представляется плоской; вы имеете API спроектированный
глубокими идиотами, которые сидят на сильнодействующих транквилизаторах.

И знаете, чаще всего приходится иметь дело со вторым вариантом. Хочется чтобы
case классы легко и непринужденно укладывались на API. И я вас пойму если так.

Но я перечислил только уважительные оправдания монструозности ваших case
классов. Есть и наиболее очевидная: для того чтобы обновить вложенное поле
глубоко запрятанного вглубь вложенных классов, приходится очень сильно
помучиться. Каждый case класс надо старательно разобрать, подменить значение
и собрать. И от этого недуга есть средство: вы можете использовать
линзы (lenses).

Почему линзы называются линзами? Потому что они способны сфокусироваться на
главном. Вы фокусируете линзу на определенную часть структуры, и получаете ее,
вместе с возможностью ее (структуру) обновить. Для начала объявим наши case
классы:

    case class Address(street: String,
                       city: String,
                       postcode: String)

    case class Person(name: String, age: Int, address: Address)

А теперь населим их данными:

    val person = Person("Joe Grey", 37,
                        Address("Southover Street",
                                "Brighton", "BN2 9UA"))

Создаем линзу для улицы (предположим что наш персонаж захотел переехать):

    import shapeless._

    val streetLens = lens[Person].address.street

Читаем поле (прошу заметить что строковый тип будет выведен автоматически):

    val street = streetLens.get(person)
    // "Southover Street"

Обновляем значение поля:

    val person1 = streetLens.set(person)("Montpelier Road")
    // person1.address.street == "Montpelier Road"

> Пример был нагло украден "из [отсюда](https://github.com/milessabin/shapeless/blob/master/examples/src/main/scala/shapeless/examples/optics.scala)"


TODO: Аллюзия к Haskell?


Аналогичную операцию вы можете совершить и над адресом. Как видите, это
достаточно просто. К сожалению, а может быть и к счастью, Scala не
имеет встроенных линз. Поэтому, вам придется использовать стороннюю
библиотеку. Я бы рекомендовал вам использовать `shapeless`. Собственно,
приведенный выше пример, был написан с помощью этой весьма доступной для
начинающего скалиста библиотеки.

Существует множество других реализаций для линз, если хотите, вы можете
использовать
[scalaz](http://eed3si9n.com/learning-scalaz/Lens.html),
[monocle](https://github.com/julien-truffaut/Monocle).
Последняя предоставляет более продвинутые механизмы использования оптики, и я
бы рекомендовал ее к дальнейшему использованию.

К сожалению, для того чтобы описать и объяснить механизм действия линз может
потребоваться отдельная статья, поэтому считаю что вышеизложенной информации
достаточно для того чтобы начать собственное исследование оптических систем.


## Переизобретение enumов
Берем опытного Java разработчика и сажаем его на Scala. Не проходит и пары
дней, и он отчаянно начинает искать enum-ы. Не находит их, и расстраивается.
В Scala нет ключевого слова `enum` или даже `enumeration`.
Далее есть два варианта событий: или он нагуглит идиоматичное решение, или
начнет переизобретать свои перечисления. Часто лень побеждает, и мы имеем вот
это:

    object Weekdays {
      val MONDAY = 0
      // догадайтесь что будет дальше...
    }

А дальше то что? А вот что:

    if (weekday == Weekdays.Friday) {
       stop(wearing, Tie)
    }

Что не так? В Scala есть идиоматичный способ создания перечислений, именуется
он ADT (Algebraic Data Types), по-русски *алгебраические типы данных*.
Используется, например в Haskell. Вот как он выглядит:

    sealed trait TrafficLight
    case object Green extends TrafficLight
    case object Yellow extends TrafficLight
    case object Red extends TrafficLight
    case object Broken extends TrafficLight

Многословно, самодельное перечисление конечно был короче. Зачем столько писать?
Давайте объявим следующую функцию:

    def tellWhatTheLightIs(tl: TrafficLight): Unit = tl match {
      case Red => println("No cars go!")
      case Green => println("Don't stop me now!")
      case Yellow => println("Ooohhh you better stop!")
    }

И получим:

    warning: match may not be exhaustive.
    It would fail on the following input: Broken
           def tellWhatTheLightIs(tl: TrafficLight): Unit = tl match {
                                                            ^
    tellWhatTheLightIs: (tl: TrafficLight)Unit

Мы получаем перечисление, свободное от привязки к каким либо константам, а так
же проверку на исчерпываемость при сопоставлении с образцом. И да, если вы
используете "enumы для бедных", как их обозвал один мой небезызвестный коллега,
используйте сопоставление с образцом. Это наиболее идиоматичный способ.
Стоит заметить, об этом упоминается в начале небезызвестной книги
[Programming in Scala](https://www.scala-lang.org/documentation/books.html).
Не каждая птица долетит до середины Днепра, так же как и не каждый скалист
прочтет *Magnum Opus*.

Неплохо про алгебраические типы данных рассказано, как ни странно, в
[Википедии](https://en.wikipedia.org/wiki/Algebraic_data_type). Касательно
Scala, есть достаточно доступный [пост](https://gleichmann.wordpress.com/2011/01/30/functional-scala-algebraic-datatypes-enumerated-types)
и [презентация](http://tpolecat.github.io/presentations/algebraic_types.html),
которая, возможно, покажется вам интересной.


## Избегайте логических аргументов в сигнатурах функций
Признайтесь, вы писали методы, которые в качестве аргумента принимают Boolean?
В случае с Java ситуация вообще катастрофичная:

    PrettyPrinter.print(text, 1, true)

Что может означать 1? Ладно, доверимся интуиции и предположим что это количество
копий. А за что отвечает `true`? Это может быть что угодно. Ладно, схожу в
исходники посмотрю что это.

В Scala вы можете использовать ADT вместо логических типов:

    def print(text: String, copies: Int, wrapWords: WordWrap)

Даже если вам достался в наследство код требующий логических аргументов, вы
можете использовать параметры по умолчанию.

    // К интам тоже применимо,
  // а вдруг это не количество копий, а отступы?
    PrettyPrinter.print(text, copies = 1, WordWrap.Enabled)


## Об итерации
### Рекурсия лучше
Зачастую, хвостовая рекурсия работает быстрее чем большинство циклов. Если она
конечно хвостовая.
чтобы убедиться в этом используйте аннотацию `@tailrec`. Но ситуации бывают
разными, не всегда рекурсивное решение оказывается простым доступным и
понятным, поэтому я
TODO:

### For comprehensions не для итерации (по индексам)
Главное, что вам следует знать про генераторы списков, или, как их еще
Называют, "for comprehensions", что основное их предназначение — не в
реализации циклов.

Более того, использование подобной конструкции для итерации по индексам будет
достаточно дорогостоящей процедурой. Цикл `while` или использование хвостовой
рекурсии — намного дешевле. И нагляднее.

"For comprehension" представляет собой синтаксический сахар для методов `map`,
`flatMap` и `withFilter`. Ключевое слово `yield` используется для последующей
агрегации значений в результирующей структуре. Используя "For comprehension" вы,
на самом деле, используете те же комбинаторы, просто в завуалированой форме.
Используйте их напрямую:

    // хорошо
    1 to 10 foreach println

    // плохо
    for (i <- 1 to 10) println(i)

помимо того что вы вызвали тот же код, вы еще и добавили некую переменную `i`,
которой совершенно здесь не место. Если вам нужна скорость, используйте цикл
`while`.


**Об именах переменных**
Занимательная история имен переменных в формате вопрос ответ:

**Вопрос**: Откуда вообще взялись `i`, `j`, `k` в качестве параметров циклов?
**Ответ**: Из математики. А в программирование они попали благодаря фортрану,
в котором тип переменной определяется ее именем, и если первая буква имени
начинается с I, J, K, L, M, или N это автоматически приводит переменную к
целочисленному типу. В противном случае, переменная будет приведена к
вещественному типу (можно использовать `IMPLICIT`, для того чтобы изменить тип
устанавливаемый по умолчанию).

И этот кошмар живет с нами вот уже почти 60 лет. Если вы не перемножаете
матрицы, то использованию `i`, `j` и `k` даже в Java нет оправдания.
Используйте `index`, `row`, `column` -- все что угодно. А вот если вы пишете на
Scala, старайтесь вообще избегать итерации с переменными внутри `for`.
От лукваого это.

Дополнением к этому разделу будет
[видео](https://www.youtube.com/watch?v=WDaw2yXAa50), в котором подробно
рассказывается все, что вы хотели знать про генераторы списков.


## О выражениях
### Не используйте return
В Scala почти все является выражением. Исключение составляет `return`, который
не следует использовать ни при каких обстоятельствах. Это не опциональное
слово. Это конструкция которая меняет семантику программы. Подробнее об этом
можете прочитать [здесь](https://tpolecat.github.io/2014/05/09/return.html)

### Не используйте метки
Представьте себе В Scala есть [метки](http://www.scala-lang.org/api/current/scala/util/control/Breaks$.html).
И я понятия не имею зачем они туда были добавлены. До выхода Scala 2.8, по
данному адресу располагалась еще и метка `continue`, позже она была устранена.

> К счастью метки не являются частью языка, и реализованы при помощи бросания (отлова)
> исключений (о том, что делать с исключениями мы поговорим далее в этой статье).

В своей практике я не встречал еще ни единого случая, когда подобное поведение
могло хоть как-то быть оправдано. Большая часть примеров, которые я нахожу в сети
притянуты за уши и высосаны из пальца. Не, ну вы посмотрите:

Этот пример взят [отсюда](http://alvinalexander.com/scala/scala-break-continue-examples-breakable):

    breakable {
      for (i <- 1 to 10) {
        println(i)
        if (i > 4) break  // выскочить из цикла.
       }
     }


## О типах
## Структурные типы, которые лучше не использовать
TODO: Рассказать о том почему они так плохи

## Stringly typed

## Привет Boolean и ADT




## Работа над ошибками

### Об исключениях
TODO:

TODO: exceptions
Failure handling:
  Try Either and Validation
  todo:

    val first = Try(Console.readLine("enter a number"))
    val second = Try(Console.readLIne("another number"))

    val sum: Try[Int] =
       for { f <- first; s <- second }
         yield f.toInt + s.toInt

  todo: add validation monad




## ? extends App
Знаете что не так с этим кодом:

    object Main extends App {
      Console.println("Hello World: " + (args mkString ", "))
    }

Конкретно с этим примером "все так". Все будет хорошо и прекрасно работать,
пока вы не усложните код достаточно, чтобы встретиться с непредсказуемым
поведением. И виной тому один трейт из стандартной библиотеки. Он называется
`DelayedInit`. Прочитать о нем вы можете [здесь](delayed-init).
Трейт `App`, который вам предлагается расширить в большинстве руководств,
расширяет трейт `DelayedInit`. Подробнее об `App` в [документации](app-doc).

> It should be noted that this trait is implemented using the DelayedInit
> functionality, which means that fields of the object will not have been
> initialized before the main method has been executed.

По-русски:

> Следует учесть, что данный трейт реализован с использованием функциональности
> DelayedInit, что означает то что поля объекта не будут проинициализированны
> до выполнения main метода.

В будущем это обещают исправить:

> Future versions of this trait will no longer extend DelayedInit.

Плохо ли использовать `App`? В сложных многопоточных приложениях я бы не стал
этого делать. А если вы пишете "Hello world"? Почему бы нет. Я стараюсь лишний
раз не связываться и использую традиционный `main` метод.

[app-doc]: http://www.scala-lang.org/api/current/scala/App.html
[delayed-init]: http://www.scala-lang.org/api/current/scala/DelayedInit.html



## Неэффективное использование коллекций
Очень часто, в коде можно увидеть эмуляцию функций стандартной библиотеки
Scala. Приведу простой пример:

    tvs.filter(tv.displaySize == 50.inches).headOption

Тоже самое, только короче:

    tvs.find(tv.displaySize == 50.inches)

Подобный "антипаттерны" тоже не редкость :

    list.size = 0  // плохо
    list.isEmpty   // ok

    !list.empty    // плохо
    list.nonEmpty  // ok

    tvs.filter(tv => !tv.supportsSkype)    // плохо
    tvs.filterNot(tv => tv.supportsSkype)  // ok

> Конечно, если вы используете IntelliJ IDEA, она вам обязательно подскажет
> наиболее эффективную комбинацию методов. Scala IDE, насколько мне известно,
> так не умеет.

О неэффективном использовании библиотеки коллекций Scala можно рассказывать
сколь угодно долго. И это уже очень не плохо сделал Павел Фатин в своей статье
[Scala collections Tips and Tricks](https://pavelfatin.com/scala-collections-tips-and-tricks).


## Хозяйственные вопросы
### Установка и настройка
А начнем мы с потугов поставить несчастную Скалу и подключить ее в проект.
Как это выглядит у обычных людей? Для начала надо скачать JDK, если вы конечно
не джавист, кложурист (или еще какой маргинал). Обязательно прописать `PATH` к
`javac`, или убедиться в том что он прописан, поставить *вашу любимую IDE*,
скачать скалу, прописать ее, скачать Sbt прописать его. Ничего не забыли?
Зачастую нужно иметь несколько разных версий Scala на вашем компьютере. Какой
кошмар! Самое время паниковать! Или использовать [SdkMan!](http://sdkman.io/install.html).
Если в двух словах, этот инструмент позволяет устанавливать различные системы
сборки и jvm-языки, и управлять их версиями. Так что применителен он не только
к Scala.

## Муки выбора IDE
Каждый раз я слышу вопрос: "А какую IDE для Scala использовать?". И знаете
какой ответ я даю? Все и сразу. Поставьте ScalaIDE, поставьте IDEA, установите
ENISME. И выберите то что вам подходит. Для работы я использую IntelliJ IDEA.
Для личных проектов vim/emacs, ScalaIDE я использую, когда IDEA снесет крышу.
Поверьте, и такое бывает. Но, как показывает практика, большинство
разработчиков остаются с IntelliJ IDEA: мышки плакали, но продолжали есть
кактус. И для многих компаний/проектов она является стандартом де-факто. В
любом случае мой совет -- ставить все. И использовать конкретные инструменты,
для конкретных задач.

IntelliJ IDEA Community Edition прекрасно поддерживает и Scala, и Dotty. И
я рекомендую использовать ее. Вы также можете воспользоваться ScalaIDE
или ENSIME Никто вам не запрещает вручную настроить Vim.

> Если все-таки вы собираетесь устанавливать Scala-IDE, проще всего сделать
> это, скачав готовую сборку IDE (нажав кнопку Download IDE) или пройдя по
> ссылке ниже. Вы также можете установить ее как плагин для Eclipse, конечно,
> если вы знаете, что делаете ☺.


## Плюсы и минусы выбора конкретной IDE
Выбирая IntelliJ IDEA, вы получаете лучшую на данный момент поддержку Scala,
огромное количество плагинов и достаточно высокую скорость работы.
Минус — если вам потребуется использовать Play framework, придется приобрести
полную версию продукта, что стоит денег. Хотя при невысоком уровне дискомфорта
можно по-прежнему обходиться Community Edition. Если у вас есть полная версия
(Ultimate), думаю, для вас выбор очевиден.

Выбирая Scala IDE, вы получаете Eclipse с отличной официальной поддержкой
Scala. Плюсы: Eclipse как свободная платформа с огромным количеством
доступных плагинов — платных и бесплатных. Вы получаете официальную
поддержку (что немаловажно). Также Play framework для Scala IDE будет работать
"из коробки". Вы его ставите и пользуетесь.

ENSIME — для тех, кто любит Vim или Emacs. Очень хорошо сделана поддержка для
Scala, и поддержку вашего любимого текстового редактора можно выделить в
качестве основного плюса. Не добавить, не убавить.




## Список литературы
В заключении этой статьи я бы порекомендовать материалов, которые я нахожу
полезными для изучения.

### Книги
[Книга](https://www.amazon.com/Programming-Scala-Updated-2-12/dp/0981531687),
которую должен прочесть каждый Scala разработчик. К сожалению, терпения хватает
не всем, однако, работа стоит затраченных усилий.

### Официальная документация
[Руководство по стилю Scala](http://docs.scala-lang.org/style/)

### Статьи
 - [Effective Scala](http://twitter.github.io/effectivescala/) для которой
   существует и [перевод](http://twitter.github.io/effectivescala/index-ru.html)
   на русский, хотя я, безусловно, советую вам ознакомиться с оригиналом.

 - [Scala Collections Tips and Tricks Павла Фатина](https://pavelfatin.com/scala-collections-tips-and-tricks/),
   и [перевод](TODO), недавно опубликованный мной на Хабре.

### Видео
 - [Scala with style](https://www.youtube.com/watch?v=kkTFx3-duc8) —
 - [Martin Odersky, Scala -- the Simple Parts](https://www.youtube.com/watch?v=ecekSCX3B4Q)
 - [Daniel Spiewak, May Your Data Ever Be Coherent](https://youtu.be/gVXt1RG_yN0)
 - [For: What is it good for?](https://www.youtube.com/watch?v=WDaw2yXAa50) --
   выступление посвященное подробному разбору, "for comprehensions".



## Благодарности
Спасибо Владу Ледовских за вычитку. Особую благодарность хотел бы выразить
@firegurafiku за вычитку и правку текста, а так же за помощь с разделом
повященным `typedef` первой части статьи. Хочу сказать отдельное спасибо
@primetalk за внесение уточнений в изначальный текст. Большое спасибо @senia,
за найденные неточности.

Спасибо EDU отделу @DataArt, а так же всем тем кто проходя наши курсы по
Scala давал повод для написания данной статьи. Если вас я здесь упомянуть забыл,
вам тоже спасибо. Спасибо вам, уважаемые читатели, что дочитали до конца.



TODOшечки:

Рассказать про салат
https://coderwall.com/p/_dxhza/scala-salad-anti-pattern

Про Null
http://alvinalexander.com/scala/best-practice-eliminate-null-values-from-code-scala-idioms
http://alvinalexander.com/scala/best-practice-option-some-none-pattern-scala-idioms


General:
https://www.quora.com/What-are-some-bad-practices-in-functional-programming
http://stackoverflow.com/questions/15848856/are-there-any-documented-anti-patterns-for-functional-programming
https://github.com/alexandru/scala-best-practices/blob/master/sections/2-language-rules.md


Exceptions:
http://stackoverflow.com/questions/13012149/is-the-use-of-exceptions-a-bad-practice-in-scala
http://stackoverflow.com/questions/12886285/throwing-exceptions-in-scala-what-is-the-official-rule
Add more information about the Validation monad


