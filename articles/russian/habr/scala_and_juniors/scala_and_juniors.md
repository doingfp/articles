# Введение

    TODO: Довести его до ума

По долгу службы в своей компании я занимаюсь не только разработкой, а так же проверяю
внутренние курсы по Scala. Помогаю освоить этот замечательный язык широкой аудитории.
Да, в нашей компании существует внутреняя образовательная система.

И каждый раз, проверяя очередную работу я рассказываю людям одно и тоже. Моя усталось
от монотонных объяснений одного и того же и привела к написанию этой статьи.

Я проверяю курсы и постоянно сталкиваюсь с одними и теми же проблемами которые присущи
не только тем кто впервые осваивает язык, но и Junior-разработчикам, которые язык освоили
и педалят что-то в проекте.

---------------------------------------------------------------

# Кортежи
Наличие кортежей (tuples) -- замечательнейшая особенность функциональных языков.
В функциональных языках, кортежи очень удобно использовать аналогично записям
(records): берем кортеж, складываем в него все необходимое, и оборачиваем в
новый тип, например используя `newtype` в Haskell[1]. В чисто-функциональных
языках без кортежей никуда: они позволяют замечательно представлять словари
(dictionaries), без них было [конволюция](convolution) была бы менее наглядной.

Scala язык объектно-ориентированный. Да, с поддержкой элементов
функционального программирования. Уверен, что многие со мной не согласятся,
но давайте не будем забывать что в Scala все есть объект. Наличие case классов
во многом снижает необходимость в кортежах: мы получаем неизменяемые записи,
которые так же можно сопоставлять с образцами, с каждым case классом уже
связан свой тип.

Кортежи приходится использовать, и пришедшим из объектно-ориентированных языков,
данные языковые средства в диковинку. Во-первых, их не именуют.

> Если кортеж не используется как анонимная помойка, его следует именовать

Для функционального стиля хорошим тоном считается использование псевдонимов
для типов (type aliasing):

    type Point = (Double, Double)

В будущем вы ссылаетесь на вполне себе именованные тип, и у вас не будет вот
таких страшных вещей:

    // плохо
    def drawLine(x: (Double, Double), y: (Double, Double)): Line = ???

    // не плохо
    def drawLine(x: Point, y: Point): Line = ???


В Scala, достучаться до элемента кортежа можно по индексу. Например:

    // Плохо!
    val y = point._2 // второй элемент

Особенно печально это выглядит при работе с коллекциями:

    // Печально!
    points foreach { point: Point =>
      println(s"x: ${point._1}, y: ${point._2}")
    }

И так делать не надо. Конечно же есть исключительные случаи, когда подобного
рода меры повышают читаемость:

    // Оправданно
    rows.groupBy(_._2)

Но в большинстве случаев, синтаксис с подчеркиванием лучше не использовать.
Про него вообще лучше забыть, и не вспоминать. В Scala существуют более
естественные способы обходиться без подобного синтаксиса.

> В Scala всегда можно обойтись без pair._2. И это нужно делать. Пожалейте
> ваших коллег, или будущего себя.

Чтобы понять и разобраться почему все именно так давайте обратимся к
функциональным языкам.

Почему индексы списков в Scala начинаются с 0, а кортежей с единицы? Ответ:
потому что так исторически сложилось. В SML для доступа к элементам списка
существуют [функции](tuples_in_sml) `#1` и `#2`.
В Haskell существуют всего две функции для доступа к элементам кортежа: `fst`
и `snd`.

    -- Как-то так. В Haskell аргументы функции идут сразу же после имени
    -- этой самой функции. Без скобок.
    fst tuple

А вот получить третий или пятый элемент кортежа просто так уже не
получится. Не верите? А [зря](tuples_in_haskell). И не поверите, если я вам
скажу что сопоставление с образцом это *наиболее естественный*. И не только в
Haskell.

**Ocaml**

    let third (_, _, elem) = elem

**Erlang**

    1> Tuple = {1,3,4}.
    {1,3,4}

    2> Third = fun ({_Fst, _Snd, Thrd}) -> Thrd end.
    #Fun<erl_eval.6.50752066>

    3> Third(Tuple).
    4

**Python**
А вот вам пример не из функционального языка
TODO: пример с шуткой природы по имени питон

А теперь давайте применим полученные знания к **Scala**

    // предположим у нас есть прямоугольник
    trait Rectangle {
      def topLeft: Point
      ...
    }

    // сопоставления с образцом при связывании
    val (x0, y0) = rectangle.topLeft

    // сопоставление с образцом внутри лямбды:
    points foreach { case (x, y) =>
      println(s"x: ${x}, y: ${y}")
    }

И да, стандартный механизм сопоставления с образцом никто не отменял.

> Так же кортежи можно использовать как анонимные помойки, и черт возьми это оправданно

Дело в том что во многих функциональных языках существует сопоставление с
образцом на уровне сигнатур функций:

    -- немного кода на haskell
    -- здесь описываются типы:
    map :: (a -> b) -> [a] -> [b]

    -- а вот тут сопоставление с образцом на уровне
    -- сигнатуры функции

    -- если нашим аргументом является
    -- пустой лист:
    map _ []  =  []

    -- более идиоматично было бы ипользование x:xs
    -- но, считаю что для людей Haskell не знающих head:tail
    -- будет нагляднее
    map fun (head:tail) = fun head : map fun tail

Аналогично для SML или Erlang. Scala такой возможности лишена. Поэтому кортежи
можно использовать для группировки и последующего сопоставления с образцом.
И да, это будет вам стоить производительности (каждый раз будет создаваться
дополнительный объект в памяти):

    // похоже на Haskell, но не то :(
    def map [A, B] (f: A => B, l: List[A]): List[B] = (f, l) match {
        case (f, Nil) => List.empty
        case (f, head::tail) => f(head) :: map(f, tail)
    }


# Options

Неправильное использование Option, является распространенной проблемой. Option,
нужен для того чтобы показать возможно отсутствующую сущность.

Один из способов правильно инициализировать сущности.
Способ концептуально продемонстрировать наличие и отсутствие некоей сущности.

    if (option.isEmpty)
      default
    else
      // без проверки взорвется
      option.get


Правильнее

    option getOrElse default

В scala существует еще один механизм который заметно облегчает работу с Option, и это...
For comprehension


    val ox = Some(1)
    val oy = Some(2)
    val oz = Some(3)

    for (x <- ox; y <- oy; z <- oz)
      yield x + y + z


    // res0: Option[Int] = 6

И если кто-то из этих ребят внезапно стает равным None

  TODO: показать что будет

## Option и flow

    TODO: Использовать Optoinы как null-check плохо.
    Гуаве гугловской, мать ее, предать привет


#Forcomps

## For-comprehensions and futures

Do you remember a stuff about options? Yep not it's a time to cover up more details:

    import scala.concurrent._
    import ExecutionContext.Implcits.global
    import duration._

    val f1 = Future { Thread sleep 10000; 6 }
    val f1 = Future { Thread sleep 10000; 5 }

    val f3 = for {
      x <- f1
      y <- f2
    } yield x * y

    f3.value6

What about other types like Either Monad:?

    val e1: Either[String, Int] = Right(6)
    val e2: Either[String, Int] = Right(7)

    for {
      x <- e1.right
      x <- e2.right
    } yield x * y



Generator
=========
putting stuff out of the container:
it has an implicit pattern matching

    for (_ <- 1 to 5) println("hi")

Вы заметили нижнее подчеркивание? Да мы только что сматчили переменную

    object Even {
      def unapply(x: Int): Boolean = x % 2 == 0
    }

    for {
      x @ Even() <- 1 to too
    } yield x


TODO: Pattern matching secrets


    The same for tuple


    for ((key, value) <- hashMap)) {
      yield key
    }

TODO:
AND THE MOST INTERESTING STUFF.. IS VAL IS ALSO A PATTERN MATCHING


Gurads (if)
=======================

for {
  i <- 1 to 10
  j <- 1 to 10
  if i % 3 == 0 || j % 3 == 0
  k <- 1 to 10
  if i * j * k % 2 == 0
} yield i * j * k


TODO: Tell about withFilter it's lazy goddamit
==============================================

inline assiGnment

val mults = for {
  i <- 1 to 5
  _ = println(s"i us $i") // or logger.info(s"$i") - SIDE EFFECT
  j <- 1 to 5
} yield i * j

Если поделим на ноль упадет быстрее. Показать на время

FORS AND DO NOTATION IN HASKELL




## Может быть список?
Может быть список, а может не быть. Речь пойдет об `Option[List[A]]`. Только
вот зачем он нужен? Давайте разберемся

А что с листом?
С листом мы имеем пустой лист и лист с элементами. Может ли он вести себя как
List? Может :) Конечно же с точки зрения теории категорий все ясно, наглядно,
понятно и очень даже очевидно. Однако для многих разрабочтиков которые не с
ней не знакомы (завидую этим парням) это не совсем очевидно


# Lists
Option has a 'get' list has a 'head' it also has 'init' and 'tail'
If those operatoions are performed on empty list you will get:

init: java.lang.UnsupportedOperationException: empty init
head: java.lang.NoSuchElementException: head of empty list
tail: java.lang.UnsupportedOperationException: tail of empty list




А знаете ли вы, один из самых лучших способов выстрелить себе в голову при
работе со списками? Позвать `list.head` (судьба Курта Кобейна не заставит
вас долго ждать).


# ООП

    TODO:

## Перегрузка конструкторов

    TODO: Рассказать про большую любовь Senior Java разработчиков грузить
    конструкторы где не попадя

# Дженерики

## Алиасте монстроту

    TODO: Алиасить монстроту надо

Опытные разарботчики грешат следующим:

(перегрузка функций когда можно использовать default параметры)

абюзинг isInstanceOf[Something] когда у нас есть надлежащий паттерн матчинг

# Смотри-ка какой паровозик
За счет того, что язык отдает предпочтение чистым функциям для совершения
большинства операций в стандартной библиотеке, у пользователя появляется
возможность строить длинные цепочки преобразований и вызовов. Многие,
познакомившись с Apache Spark так и делают, и ничего в зазорного в этом не
видят, Однако подобный код очень и очень неудобно читать. Это первое что
делают новички пришедшие в Scala. Им это нравится, они упиваются своим
могуществом и получают от этого не сравнимое удовольствие. Пожалуйста,
разбивайте ваши цепочки на несколько именованных valов. Это будет намного
читабельнее и осмысленнее, возможно, вы даже уложитесь в волшебные 80 колонок.


# Shooting youtself in the foot

## Не надо тут extends App
Рассказать про Delayed init


## annotation.implcitNotFound

## Не используйте структурные типы: structual types

    val s = new Object { val name = Foo }
    s.name

Что происходит внутри?
  РЕФЛЕКСИЯ



Problems with implicit

Problems with partial applications


# Заключение
Что я этим хотел сказать



# Литература
Очень рекомендую посмотреть
 - [Scala with style](scala_with_style).
 - [May Your Data Ever Be Coherent](coherent_data).
 - [Scala style guide от Databricks](databricks-style-guide)


[1]: https://wiki.haskell.org/Newtype
[convolution]: https://en.wikipedia.org/wiki/Convolution_(computer_science)
[tuples_in_haskell]: http://stackoverflow.com/questions/15558278/how-to-get-nth-element-from-a-10-tuple-in-haskell
[tuples_in_sml]: http://www.cs.cornell.edu/courses/cs312/2004fa/lectures/lecture3.htm
[scala_with_style]: https://www.youtube.com/watch?v=kkTFx3-duc8
[coherent_data]: https://www.youtube.com/watch?v=gVXt1RG_yN0
[scala-and-dotty-puzzlers]: https://youtu.be/Ay-9aanosUM
[databricks-style-guide]: https://github.com/databricks/scala-style-guide
