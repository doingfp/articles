По долгу службы в своей компании я занимаюсь не только разработкой, а так же проверяю
внутренние курсы по Scala. Помогаю освоить этот замечательный язык широкой аудитории.
Да, в нашей компании существует внутреняя образовательная система.

И каждый раз, проверяя очередную работу я рассказываю людям одно и тоже. Моя усталось
от монотонных объяснений одного и того же и привела к написанию этой статьи.

Я проверяю курсы и постоянно сталкиваюсь с одними и теми же проблемами которые присущи
не только тем кто впервые осваивает язык, но и Junior-разработчикам, которые язык освоили
и педалят что-то в проекте.

---------------------------------------------------------------

# Кортежи
Наличие кортежей (tuples) -- замечательнейшая особенность функциональных языков.
В функциональных языках, кортежи очень удобно использовать аналогично записям
(records): берем кортеж, складываем в него все необходимое, и оборачиваем в
новый тип, например используя `newtype` в Haskell[1]. В чисто-функциональных
языках без кортежей никуда: они позволяют замечательно представлять словари
(dictionaries), без них было [конволюция](convolution) была бы менее наглядной.

Scala язык объектно-ориентированный. Да, с поддержкой элементов
функционального программирования. Уверен, что многие со мной не согласятся,
но давайте не будем забывать что в Scala все есть объект. Наличие case классов
во многом снижает необходимость в кортежах: мы получаем неизменяемые записи,
которые так же можно сопоставлять с образцами, с каждым case классом уже
связан свой тип.

Кортежи приходится использовать, и пришедшим из объектно-ориентированных языков,
данные языковые средства в диковинку. Во-первых, их не именуют.

>> Если кортеж не используется как анонимная помойка, его следует именовать

Для функционального стиля хорошим тоном считается использование псевдонимов
для типов (type aliasing):

    type Point = (Double, Double)

В будущем вы ссылаетесь на вполне себе именованные тип, и у вас не будет вот
таких страшных вещей:

    // плохо
    def drawLine(x: (Double, Double), y: (Double, Double)): Line = ???

    // не плохо
    def drawLine(x: Point, y: Point): Line = ???


В Scala, достучаться до элемента кортежа можно по индексу. Например:

    // Плохо!
    val y = point._2 // второй элемент

Особенно печально это выглядит при работе с коллекциями:

    // Печально!
    points foreach { point: Point =>
      println(s"x: ${point._1}, y: ${point._2}")
    }

И так делать не надо. Конечно же есть исключительные случаи, когда подобного
рода меры повышают читаемость:

    // Оправданно
    rows.groupBy(_._2)

Но в большинстве случаев, синтаксис с подчеркиванием лучше не использовать.
Про него вообще лучше забыть, и не вспоминать. В Scala существуют более
естественные способы обходиться без подобного синтаксиса.

>> В Scala всегда можно обойтись без pair._2. И это нужно делать. Пожалейте
>> ваших коллег, или будущего себя.

Чтобы понять и разобраться почему все именно так давайте обратимся к
функциональным языкам.

Почему индексы списков в Scala начинаются с 0, а кортежей с единицы? Ответ:
потому что так исторически сложилось. В SML для доступа к элементам списка
существуют [функции](tuples_in_sml) `#1` и `#2`.
В Haskell существуют всего две функции для доступа к элементам кортежа: `fst`
и `snd`.

    -- Как-то так. В Haskell аргументы функции идут сразу же после имени
    -- этой самой функции. Без скобок.
    fst tuple

А вот получить третий или пятый элемент кортежа просто так уже не
получится. Не верите? А [зря](tuples_in_haskell). И не поверите, если я вам
скажу что сопоставление с образцом это *наиболее естественный*. И не только в
Haskell.

**Ocaml**

    let third (_, _, elem) = elem

**Erlang**

    1> Tuple = {1,3,4}.
    {1,3,4}

    2> Third = fun ({_Fst, _Snd, Thrd}) -> Thrd end.
    #Fun<erl_eval.6.50752066>

    3> Third(Tuple).
    4

А теперь давайте применим полученные знания к **Scala**

    // предположим у нас есть прямоугольник
    trait Rectangle {
      def topLeft: Point
      ...
    }

    // сопоставления с образцом при связывании
    val (x0, y0) = rectangle.topLeft

    // сопоставление с образцом внутри лямбды:
    points foreach { case (x, y) =>
      println(s"x: ${x}, y: ${y}")
    }

И да, стандартный механизм сопоставления с образцом никто не отменял.

>> Так же кортежи можно использовать как анонимные помойки, и черт возьми
>> это оправданно

Дело в том что во многих функциональных языках существует сопоставление с
образцом на уровне сигнатур функций:

    -- немного кода на haskell
    -- здесь описываются типы:
    map :: (a -> b) -> [a] -> [b]

    -- а вот тут сопоставление с образцом на уровне
    -- сигнатуры функции

    -- если нашим аргументом является
    -- пустой лист:
    map _ []  =  []

    -- более идиоматично было бы ипользование x:xs
    -- но, считаю что для людей Haskell не знающих head:tail
    -- будет нагляднее
    map fun (head:tail) = fun head : map fun tail

Аналогично для SML или Erlang. Scala такой возможности лишена. Поэтому кортежи
можно использовать для группировки и последующего сопоставления с образцом.
И да, это будет вам стоить производительности (каждый раз будет создаваться
дополнительный объект в памяти):

    // похоже на Haskell, но не то :(
    def map [A, B] (f: A => B, l: List[A]): List[B] = (f, l) match {
        case (f, Nil) => List.empty
        case (f, head::tail) => f(head) :: map(f, tail)
    }


# Options

    TODO:

Неправильное использование Option, является распространенной проблемой. Option,
нужен для того чтобы показать возможно отсутствующую сущность.

Один из способов правильно инициализировать сущности.
Способ концептуально продемонстрировать наличие и отсутствие некоей сущности.


## Может быть список?
Может быть список, а может не быть. Речь пойдет об `Option[List[A]]`. Только
вот зачем он нужен? Давайте разберемся

А что с листом?
С листом мы имеем пустой лист и лист с элементами. Может ли он вести себя как
List? Может :) Конечно же с точки зрения теории категорий все ясно, наглядно,
понятно и очень даже очевидно. Однако для многих разрабочтиков которые не с
ней не знакомы (завидую этим парням) это не совсем очевидно

----


Опытные разарботчики грешат следующим:

(перегрузка функций когда можно использовать default параметры)

абюзинг isInstanceOf[Something] когда у нас есть надлежащий паттерн матчинг

# Смотри-ка какой паровозик
За счет того, что язык отдает предпочтение чистым функциям для совершения
большинства операций в стандартной библиотеке, у пользователя появляется
возможность строить длинные цепочки преобразований и вызовов. Многие,
познакомившись с Apache Spark так и делают, и ничего в зазорного в этом не
видят, Однако подобный код очень и очень неудобно читать. Это первое что
делают новички пришедшие в Scala. Им это нравится, они упиваются своим
могуществом и получают от этого не сравнимое удовольствие. Пожалуйста,
разбивайте ваши цепочки на несколько именованных valов. Это будет намного
читабельнее и осмысленнее, возможно, вы даже уложитесь в волшебные 80 колонок.




# Литература
Очень рекомендую посмотреть доклад Одерски [Scala with style](scala_with_style).


[1]: https://wiki.haskell.org/Newtype
[convolution]: https://en.wikipedia.org/wiki/Convolution_(computer_science)
[tuples_in_haskell]: http://stackoverflow.com/questions/15558278/how-to-get-nth-element-from-a-10-tuple-in-haskell
[tuples_in_sml]: http://www.cs.cornell.edu/courses/cs312/2004fa/lectures/lecture3.htm
[scala_with_style]: https://www.youtube.com/watch?v=kkTFx3-duc8
