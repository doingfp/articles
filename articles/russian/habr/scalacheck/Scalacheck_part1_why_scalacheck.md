Про Scalacheck
==============
**Часть 1. Зачем Scalacheck**.

Scalacheck - это [комбинАторная](combinator-library) библиотека значительно
облегчающая написание модульных тестов на Scala. В ней используется подход
property-based тестирования впервые реализованного в библиотеке
[Quickcheck](quickcheck-intro) для языка Haskell. Существует множество
реализаций Quickcheck: есть реализации для [Java](quickcheck-java),
[C](quickcheck-c), а так же [других](quickcheck-wiki) языков и платформ.

Эта серия статей во многом похожа на мою [предыдущую](parboiled) посвященную
`Parboiled`, поэтому структура этой серии статей будет похожей. Здесь вы узнаете
о подходе именуемом Property-based testing, который на русский можно перевести
как "свойство-ориентированное тестирование". Использование данного подхода
позволяет значительно сократить время на разработку тестов. В этой и последующих
статьях мы научимся смотреть на мир сквозь свойства, пощупаем генераторы.
Заинтересовало? Прошу под кат :).

[combinator-library]: https://en.wikipedia.org/wiki/Combinator_library
[quickcheck-wiki]: https://en.wikipedia.org/wiki/QuickCheck
[quickcheck-intro]: http://www.stuartgunter.org/intro-to-quickcheck/
[quickcheck-c]: https://github.com/silentbicycle/theft
[quickcheck-java]: https://github.com/pholser/junit-quickcheck/
[parboiled]: https://habrahabr.ru/post/270233/


**Структура цикла**

 - Зачем `Scalacheck`
 - Генераторы
 - Свойства
 - Минимизация
 - Интеграция и настройки

<cut text="Читать про Scalacheck →">

# Введение
Модульное тестирование является одним из важнейших подходов в разработке
программного обеспечения. И даже если ваша программа проходит различные проверки
типов, это еще не означает что в ней отсутствуют логические ошибки. Стоимость
тестирования является высокой - помимо потраченных человеко-часов, требуется
тратить нечеловеко-yсилия на выполнение рутинного написания модульных тестов.
Именно поэтому многие заказчики экономят на модульном тестировании, а многие
программисты пользуются этим с превеликой разницей. Модульные тесты писать
скучно, но нужно.

Использование функциональной парадигмы значительно облегчает модульное
тестирование - отсутствие побочных эффектов позволяет рассматривать меньше
краеугольных случаев и забыть о тестировании состояния. Объем тестирующего кода
это значительно не сокращает, и скорее всего найдется найдется случай, который
вы упустили из виду. Однако подход даст вам определенные гарантии и некоторую
уверенность в вашем коде.

Даже функциональный и типобезопасный код нужно тестировать. Но согласитесь,
покрывать огромное количество случаев, и писать однотипные синтаксические
конструкции изо дня в день - удовольствие сомнительное.

Свойство-ориентированное тестирование позволяет значительно повысить читаемость
при сокращении объема тестирующего кода повышая его ремонтопригодность. Покрытие
вашего кода тестами также заметно возрастет. Для начала давайте разберемся в том
как это работает.


# Свойство-ориентированное тестирование

## Свойствах в общем
Итак, давайте для начала разберемся в том, что является свойством. Если в двух
словах, то свойство это логическое выражение. На него можно смотреть как на
некоторый закон, или правило, можно как на некий атрибут черного ящика. Нас не
волнует состояние тестируемой функции, нас волнуют входные и выходные данные,
спецификация. Вот простейший пример свойства, для понимающих *"греческий"*:

    ∀x ∈ ℝ: x ≠ 0 → x² > 0

> Если вы не понимаете греческий, не отчаивайтесь, дальше все будет
> изложено на английском

    // автор прекрасно понмиает что Double никогда не являлся ℝ,
    // однако, для упрощения понимания, этим безспорно важным свойством
    // придется пожертвовать
    forall { x: Double => (x > 0) ==> x * x > 0 }

По-русски это читается так: "Для любого x > 0, x² всегда будет больше 0".

Как видите, свойство представляет собой более высокий уровень абстракции, нежели
традиционный тест assertion-based тест в `JUnit`. После достаточно абстрактного
описания свойств, `Scalacheck` выполняет вполне конкретные тесты, сопоставимые
по качеству с теми, которые бы вы писали руками.

## Это не теории
`JUnit` 4 обладает одной уникальной функцией, которая называется Theories. Еще
бы они их гипотезами назвали. Теории работают весьма похожим образом, но в
отличии от `Scalacheck`, они не позволяют генерировать входные данные
произвольным образом, а так же выполнять минимизацию (shrinking).

> Далее я буду использовать возможно не очень корректный термин 'минимизация'
> в качестве вполне понятного термина 'shrinking'. Сужение, уж простите,
> звучит как диагноз.

Итак, что представляют из себя теории? Теория проверяет утверждение о том, что
некоторое условие всегда верно для набора заданных данных (они же data points).
Количество data points неограниченно. Для того чтобы ваш метод стал теорией, его
нужно соответствующим образом проаннотировать: добавить `@Theory`. Входные
данные аннотируются как `@DataPoint`. Раннер запускает тест каждый раз для
каждого из дата-поинтов. Вот небольшой пример, нагло позаимствованный из
документации `JUnit`:

    @RunWith(Theories.class)
    public class UserTest {

       // Первый источник данных
       @DataPoint
       public static String GOOD_USERNAME = "optimus";

       // Последний источник данных
       // на нем и упадет
       @DataPoint
       public static String USERNAME_WITH_SLASH = "optimus/prime";

          @Theory
          public void filenameIncludesUsername(String username) {
              assumeThat(username, not(containsString("/")));
              assertThat(new User(username).configFileName(),
                         containsString(username));
          }
    }

Механизм похож на тот что использует `Scalacheck`. Существует лишь два
существенных отличия:

 - `Scalacheck` сам генерирует тесты
 - Из всех, *случайным образом сгенерированных* тестов, `Scalacheck` выбирает
   наиболее частный результат, когда тест ломается.

Поэтому согласитесь, что в сравнении с теориями, `Scalacheck` так же выигрывает,
как по объему кода, так и по количеству тестов. Узнать больше о теориях, вы
можете [здесь](more-on-theories).

[junit-theories]: https://github.com/junit-team/junit4/wiki/Theories
[more-on-theories]: http://web.archive.org/web/20110608210825/http://shareandenjoy.saff.net/tdd-specifications.pdf


## Плюсы и минусы property-based подхода
`ScalaCheck` создавался не для того чтобы полностью вытеснить `ScalaTest` или
пресловутый `JUnit`, а для того чтобы внести в процесс модульного тестирования
следующие дополнительные преимущества:

+ Лаконичность: меньше кода / выше покрытие в сравнении со стандартным
  (assertion-based) подходом
+ Высокоуровневость: мы фокусируемся на входных данных, а не на частных случаях.
+ Минимизация: когда что-то сломалось, нам помогут (или мы поможем себе сами)
+ Наличие сущностей, которые проще тестировать как единое целое, нежели
  тестировать их покомпонентно.

Свойство-ориентированное тестирование не серебряная пуля. У этого подхода есть и
тоже недостатки:

- Медленный код убивает процесс тестирования. (Хотя возможно, это и плюс. Моей
  практике известны случаи, когда использование Scalacheck заставляло задуматься
  об оптимизации. Иногда можно подождать.
- Зачастую ложное ощущение собственной безопасности. Мы думаем, и уверенны что
  покрыли тестами все что могли, хотя порой это не всегда так.
- Нечувствительность к граничным условиям
- Равномерное распределение для случайных результатов, это тоже плюс. Однако не
  всегда это бывает полезно.

## Когда использовать?
Scalacheck можно использовать так же как и любой другой фреймворк для
тестирования, да, придется думать несколько иначе, однако Scalacheck позволяет
вам написать практически любой тест. Просто не всегда это эффективно, удобно и
читаемо. Однако есть области где Scalacheck будет более эффективен.

+ Код крайне чувствительный к входным данным
+ Конечные автоматы или любые системы, зависимые от состояния
+ Парсеры -- то для чего использую Scalacheck лично я
+ Различные [преобразователи данных][data-processors]:
  + Валидаторы
  + Классификаторы
  + Агрегаторы
  + Сортировщики.. и тд
+ Spark RDD, а также маеры и редьюсеры для Hadoop

[data-processors]: https://en.wikipedia.org/wiki/Data_processing


# Scalacheck

## Особенности библиотеки
Scalacheck это:
- компактная библиотека (содержит меньше 20 .scala файлов)
- отсутствие дополнительных зависимостей
- поддержка stateful testing
- не использует `java.util.Random` в качестве генератора псевдослучайных чисел.
  Более того, `Scalacheck` внимательно следит за тем, чтобы при генерации
  случайных данных результаты не повторялись, используя [поиск с возвратом][backtracking]
- поддержка scala-js и Dotty

> Внутри `java.util.Random` используется [линейный конгруэнтный][lcg] метод
> генерации псевдослучайных последовательностей, далее LCG. Подробнее вы можете
> прочитать в официальной [документации][jur]. LCG не обеспечивают достаточного
> качества генерации псевдослучайных чисел, и используются в большинстве
> библиотек исключительно за счет простоты и высокой производительности. Внутри
> Scalacheck использует свой генератор, который гораздо лучше ведет себя на
> больших статистических вычислениях. Подробнее о генераторе вы можете узнать
> [здесь][ssrng].

[stateful-scalacheck]: http://scalacheck.org/files/scaladays2014/#1
[lcg]: https://en.wikipedia.org/wiki/Linear_congruential_generator#Advantages_and_disadvantages
[backtracking]: https://en.wikipedia.org/wiki/Backtracking
[jur]: https://docs.oracle.com/javase/8/docs/api/java/util/Random.html
[ssrng]: http://burtleburtle.net/bob/rand/smallprng.html


## Подготовительные работы
После того, как мы определились с тем, нужно ли нам свойство-ориентированное
тестирование и Scalacheck в частности, давайте приступим к подготовительным
работам. Добавьте следующую зависимость в ваш проект, я рассчитываю что вы,
уважаемый читатель, уже перешли на Scala 2.12:

    <!-- Пользователи sbt и gradle скорее всего знают о Maven -->
    <dependency>
        <groupId>org.scalacheck</groupId>
        <artifactId>scalacheck_2.12</artifactId>
        <version>1.13.4</version>
    </dependency>

Так же предполагается, что вы используете последнюю версию. Существует
[проблема](deadlock-problem) при использовании устаревших версий библиотеки
в связке с Scala 2.12. Будьте осторожны.

[deadlock-problem]: https://github.com/rickynils/scalacheck/issues/290

Как уже было сказано ранее, Scalacheck построен на двух основных концепциях:
на свойствах и генераторах. Свойства хорошо освещены во множестве блогов, в том
числе и русскоязычных. Поэтому больше внимания я постараюсь уделить генераторам.
В этой части мы **бегло** ознакомимся как со свойствами, так и с генераторами.

## Немного о свойствах
Свойство представляет собой минимальный тестируемый модуль. Представляется
экземпляром класса `org.scalacheck.Prop`. Простейший пример:

    import org.scalacheck.Prop

    val propStringLengthAfterConcat = Prop forAll { s: String =>
      val len = s.length
      (s + s).length == len + len
    }

    // Только при наличии конкретного типа исключения, свойство будет считаться
    // успешным
    val propDivByZero = Prop.throws(classOf[ArithmeticException] {1/0}

    // Для любого целочисленного списка, при доступе к элементу индекс которого
    // на единицу больше его длины, всегда будет выброшено
    // исключение IndexOutOfBoundsException
    val propListIndexOutOfBounds = Prop forAll { xs: List[Int] =>
      Prop.throws(classOf[IndexOutOfBoundsException]) {
        xs(xs.length + 1)
      }

## Немного о генераторах
На практике, генераторы приходится писать не реже чем свойства. Для того чтобы
воспользоваться ими, вам следует проимпортировать `org.scalacheck.Gen`.

    import org.scalacheck.Gen

    // генерируем диапазон необходимых значений
    val binaryDigit = Gen.choose(0, 1)
    val octDigit    = Gen.choose(0, 7)

    // Равновероятно выбирает единственное значение из всех перечисленных.
    val vowel = Gen.oneOf('a', 'e', 'i', 'o', 'u')

Также в Scalacheck имеется набор генераторов для стандартных типов:

    val alphaLower = Gen.alphaLowerChar

    // Сгенерирует строку, которая начинается со строчной буквы,
    // дальнейшие символы могут быть только цифрами или буквами
    val identifier = Gen.identifier

    val natural = Gen.posNum[Long]

Вы также можете объединять имеющиеся генераторы, применять ним `map`, и for
comprehension:

    val personGen = for {
      charValue <- Gen.oneOf("Jason", "Oliver", "Jessica", "Olivia")
      ageValue  <- Gen.posNum[Int]
    } yield Person (name = nameValue, age = ageValue)

И свойства и генераторы мы рассмотрим подробнее в следующих статьях. Следующая
статья серии будет посвящена генераторам. Спасибо что дочитали, оставайтесь
на связи.

