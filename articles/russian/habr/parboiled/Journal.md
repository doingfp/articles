Про Parboiled
=============

# Введение
Сегодня, в свете бурного роста популярности функциональных языков программирования, всё чаще находят себе применение
комбинаторы парсеров — инструменты, облегчающие разбор текста простым смертным. Такие библиотеки, как [Parsec]
(Haskell) и [Planck] (OCaml) уже успели хорошо себя зарекомендовать в своих экосистемах. Их удобство и возможности в
своё время подтолкнули создателя языка Scala, Мартина Одерски, внести в стандартную библиотеку их аналог —
[Scala Parser Combinators][spc] (ныне вынесены в [scala-modules][sm]), а знание и умение пользоваться подобными
инструментами — отнести к обязательным требованиям к Scala-разработчикам [уровня A3][a3].

[Parsec]: https://wiki.haskell.org/Parsec
[Planck]: https://bitbucket.org/camlspotter/planck
[spc]: https://github.com/scala/scala-parser-combinators
[sm]:  http://mvnrepository.com/artifact/org.scala-lang.modules
[a3]:  http://www.scala-lang.org/old/node/8610

Эта статья посвящена библиотеке [Parboiled][pb] — мощной альтернативе и возможной замене для Scala Parser
Combinators. В ней мы подробно рассмотрим работу с текущей версией библиотеки — Parboiled2, а также уделим внимание
Parboiled1, так как большая часть существующего кода всё ещё использует именно её.

[pb]: https://github.com/sirthias/parboiled

Parboiled — библиотека, позволяющая с легкостью разбирать (парсить) языки разметки (такие как HTML, XML или JSON),
языки программирования, конфигурационные файлы, логи, текстовые протоколы и вообще что угодно текстовое. Parboiled
придётся весьма кстати, если вы захотите разработать свой предметно-ориентированный язык ([DSL][dsl]): с её помощью вы
сможете быстро получить [абстрактное синтаксическое дерево][ast] и, вспомнив паттерн [интерпретатор][ip], исполнять
команды вашего доменного языка.

[ast]: https://en.wikipedia.org/wiki/Abstract_syntax_tree
[ip]:  https://en.wikipedia.org/wiki/Interpreter_pattern
[dsl]: https://en.wikipedia.org/wiki/Domain-specific_language

На данный момент существует несколько версий данной библиотеки:

  - Parboiled for Java — самая первая версия библиотеки. Написана Маттиасом Дёницем (Matthias Doeniz)
    на Java и для Java. До сих пор пользуется популярностью, хоть и находится в состоянии «end of life». Если по воле
    случая она досталась вам в наследство, или же вы сознательно начинаете проект на Java, советую рассмотреть в
    качестве альтернативы [grappa][grappa] — форк Parboiled1, который старательно поддерживается в работоспособном
    состоянии пользователем с ником [fge][fge].

  - Parboiled — библиотека, теперь уже более известная как Parboiled1, появилась на свет после того, как
    Маттиас увлекся Scala. Он сделал Scala-фронтэнд для Parboiled, заодно забросив поддержку Java-версии. С выходом
    Parboiled2 потихонечку перестает поддерживаться и Scala-версия Parboiled1, однако не смотря на это, списывать её
    со счетов пока что не стоит:

      - Parboiled2 пока что не научился всем фичам Parboiled1;
      - Parboiled1 всё ещё используется гораздо шире, чем Parboiled2, поэтому если вы внезапно окажетесь на
        какой-нибудь старом Scala-проекте, высок шанс столкнуться именно с ним.

  - Parboiled2 — новейшая версия библиотеки, устраняющая ряд недостатков PB1. Работает быстрее и, что самое главное,
    поддерживается разработчиками.

[grappa]: https://github.com/fge/grappa
[fge]:    https://github.com/fge

Я писал эту статью с упором на Parboiled2 (кстати, дальше я буду писать о нём в мужском роде, без слова «библиотека»),
но иногда я буду отвлекаться, чтобы рассказать о важных отличиях между первой и второй версиями.


# Основные возможности
Краткая характеристика Parboiled2:

  - Следует принципам [PEG](https://en.wikipedia.org/wiki/Parsing_expression_grammar).
  - Генерирует однопроходные парсеры. Отдельный лексер не требуется.
  - Используется типобезопасный DSL, являющийся подмножеством языка Scala.
  - Оптимизации выполняются на этапе компиляции.

На практике это означает:

  - Вам не нужно писать парсер самостоятельно.
  - Читаемость, сравнимую с лучшими видами BNF.
  - Можно использовать всю мощь PEG и свободно разбирать рекурсивные структуры данных, в то время как регулярные
    выражения не могут этого [по определению][hier]. Да, регулярными выражениями вы не распарсите ни JSON, ни даже
    простейшее арифметическое выражение, что уж говорить о языках программирования. На StackOverflow есть
    [небезызвестная цитата в тему][paris]:

    > Asking regexes to parse arbitrary HTML is like asking Paris Hilton to write an operating system.

[paris]: http://stackoverflow.com/a/1733489/1447225
[hier]:  https://en.wikipedia.org/wiki/Chomsky_hierarchy#The_hierarchy

  - Даже если вам нужно разобрать линейную структуру, Parboiled2 (при использовании должных оптимизаций) будет
    работать быстрее регулярных выражений. Доказательства приведены в следующем разделе.

  - В отличие от генераторов парсеров, таких как [ANTLR], вы освобождены от неудобств связанных с раздельной генерацией
    кода и последующей его компиляцией. Весь код с Parboiled пишется на Scala, поэтому вы получаете подсветку синтаксиса
    и проверку типов из коробки, так же как и отсутствие дополнительных операций над файлами грамматик, в то время
    как парсер, сгенерированный ANTLR, будет иметь две фазы синтаксического разбора. Правда, несмотря на это,
    ANTLR всё равно мощнее, документированее и стабильнее, и поэтому может оказаться предпочтительнее во многих весьма
    нетривиальных случаях.

[ANTLR]: http://www.antlr.org/

  - Скаловские парсер-комбинаторы работают неприлично медленно. Маттиас проводил сравнение производительности парсеров
    для Jackson и JSON, написанных с помощью Parboiled, Parboiled2 и Scala Parser Combinators. С неутешительными
    результатами для последних можно ознакомиться дальше по тексту.

  - В отличие от [Language Workbenches][lwb], Parboiled — маленькая и простая в использовании библиотека. Вам не нужно
    скачивать плохо документированного тормозящего монстра и тратить драгоценные часы жизни на изматывающий поиск
    нужных менюшек и кнопочек всего-навсего для описания небольшого DSL. С другой стороны, вы не получите готовый
    текстовый редактор с подсветкой вашего DSL «из коробки», вместо этого вам придется самостоятельно написать плагин
    для Vim, Emacs или вашей IDE, но это не делает Parboiled менее достойной альтернативой для разработки небольших
    предметно-ориентированных языков.

[lwb]: http://martinfowler.com/bliki/LanguageWorkbench.html

  - Parboiled успешно зарекомендовал себя во [многих проектах][proj].

[proj]: https://github.com/sirthias/parboiled/wiki/Projects-using-parboiled


# Нововведения второй версии
Этот раздел, в основном, будет полезен и понятен тем, кто уже работал с первой версией библиотеки. Новичкам, скорее
всего, стоит вернуться к этому списку после прочтения всей статьи.

Прежде всего, Parboiled2 успешно устраняет ряд детских болезней первой версии:

  - Появилась возможность использовать правила более вместительные, чем `Rule7`. Для этого была использована библиотека
    [shapeless][shapeless] с ее знаменитыми `HListами`: теперь одно правило может оперировать большим количеством
    значений на стеке. Это также означает, что в Parboiled2 появилась дополнительная зависимость, которой не было
    в PB1 — сама библиотека shapeless.

  - Добавлены недостающие конструкции. Так, в Parboiled1 нельзя было указать динамическое количество повторений
    для правила `nTimes` и приходилось использовать более «мягкое» правило `oneOrMore`, что не давало нужной точности
    описания грамматики.

  - Добавлены встроенные примитивные терминалы. Появился новый класс `CharPredicate`, который содержит такие поля,
    как `AlphaNumeric`, `Hex`, `Printable`, `Visible` и другие.

  - Добавлена возможность расширения и сужения предиката. Потребность исключить несколько символов из правила
    возникала и раньше, но только теперь это можно с легкостью взять и сделать, а не создавать белый список символов.

Кроме того:

  - Parboiled2 использует макросы, что позволяет генерировать грамматику на этапе компиляции, а не во время выполнения,
    как это было в Parboiled1. Это многократно увеличивает производительность вашего парсера, так же как увеличивает
    количество проверок. В связи с этим блок `rule` стал обязательным, хотя Parboiled1 позволял в некоторых случаях
    обходиться без него. Это нововведение вы заметите в первую очередь, когда будете делать миграцию старого кода.

  - Улучшена система отчета об ошибках.

  - Появилась поддержка [scala.js][scalajs]. Демо-проект можно посмотреть [здесь][scalajs-demo].

[shapeless]:    https://github.com/milessabin/shapeless
[scalajs]:      http://www.scala-js.org/
[scalajs-demo]: https://github.com/alexander-myltsev/parboiled2-scalajs-samples


# Сравнения производительности
Parboiled1 известен своей медлительностью (по отношению к парсерам, генерируемым ANTLR), вызванной тем, что все
действия по сопоставлению правил выполнялись во время выполнения программы и компилятор не мог производить
над таким парсером каких-либо существенных оптимизаций. В Parboiled2 во главу угла поставили производительность
и многие вещи были переделаны на макросах, благодаря чему компилятор получил свободу действий при оптимизации, а
пользователь — долгожданную производительность. Ниже мы продемонстрируем, каких неплохих результатов добились
разработчики.


## Parboiled в сравенении с парсерами JSON
Parboiled — это обобщённый инструмент для создания парсеров, а как известно, специализированный инструмент всегда
оказывается лучше обобщённого в решении своей специализированной задачи. В мире Java существует небольшое количество
высокопроизводительных парсеров JSON, и Александр Мыльцев (один из разработчиков Parboiled2) проверил, насколько сильно
Parboiled проигрывает им в производительности. [Результаты][bench-elv] оказались достаточно оптимистичными, особенно в
случае с Parboiled2.

[bench-elv]: http://myltsev.name/ScalaDays2014/#/

      Тест-кейс                           │ Время, мс │
    ──────────────────────────────────────┼───────────┼─────────────────────────────────
      Parboiled1JsonParser                │     85.64 │ ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇
      Parboiled2JsonParser                │     13.17 │ ▇▇▇▇
      Json4SNative                        │      8.06 │ ██▍
      Argonaut                            │      7.01 │ ▇▇
      Json4SJackson                       │      4.09 │ ▇


## Parboiled против регулярных выражений
Благодаря использованию статических оптимизаций, Parboiled2 способен работать значительно быстрее регулярных выражений
(как минимум тех, что идут в комплекте с библиотекой классов Java). Вот немного подтверждающих данных
из [списка рассылки][bench-re]:

      Тест-кейс                           │ Время, мс │
    ──────────────────────────────────────┼───────────┼───────────────────────────────────
      Parboiled2 (warmup)                 │   1621.21 │ ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇
      Parboiled2                          │    409.16 │ ▇▇▇▇▇▇▇▇
      Parboiled2 w/ better types (warmup) │    488.92 │ ▇▇▇▇▇▇▇▇▇▇
      Parboiled2 w/ better types          │    134.68 │ ▇▇▇
      Regex (warmup)                      │    621.95 │ ▇▇▇▇▇▇▇▇▇▇▇▇
      Regex                               │    620.38 │ ▇▇▇▇▇▇▇▇▇▇▇▇

[bench-re]: https://groups.google.com/forum/#!msg/parboiled-user/XATcJRLTXjA/XSmf3n6gZSwJ


## Parboiled против Scala Parser Combinators
В списке рассылки можно найти и [другой тест производительности][bench-spc], который неплохо согласуется с первым
(про JSON) и содержит данные для сравнения со Scala Parser Combinators. Всё очень и очень печально.

      Тест-кейс                           │ Время, мс │
    ──────────────────────────────────────┼───────────┼─────────────────────────────────
      Parboiled1JsonParser                |     73.81 | ▇
      Parboiled2JsonParser                |     10.49 | ▎
      ParserCombinators                   |   2385.78 | ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇

[bench-spc]: https://groups.google.com/forum/#!topic/parboiled-user/bGtdGvllGgU


# Чего Parboiled не может
Ввиду того что Parboiled основан на концепции PEG, он принципиально не умеет:

 - Разбирать леворекурсивные грамматики. Это не под силу всем нисходящим парсерам (top-down parsers), к коим относятся
   и PEG. Однако, леворекурсивную грамматику можно [адаптировать][lrg-adapt].

[lrg-adapt]: http://neerc.ifmo.ru/wiki/index.php?title=Устранение_левой_рекурсии

 - Разбирать грамматики на отступах (indentation-based grammars), например Python или YAML. Не получается это сделать
   из-за того, что сгенерированный парсер является однопроходным, без отдельного лексера. Разбор отступов же
   выполняется на этапе лексического анализа. У этой проблемы есть простое решение: напишите препроцессор, который
   расставит виртуальные маркеры до (`INDENT`) и после (`DEDENT`) выхода в отступ. В Parboiled1 имеются для этого
   [стандарные инструменты][pb1-ibg], но для Parboiled2 подобную процедуру пока что придётся выполнять самостоятельно.

[pb1-ibg]: https://github.com/sirthias/parboiled/wiki/Indentation-Based-Grammars

 - Использовать потоковый ввод (streaming input). PEG используют поиск с возвратом, он же [бэктрекинг][backtracking].
   Теоретически, этот недостаток можно устранить при помощи буферизации потока, но ничто не мешает написать такую
   грамматику, в которой происходит возврат к самому началу. Поэтому, чтобы эта идея заработала на практике, необходимо
   научиться определять по грамматике границы чанков, между которыми возврат невозможен. Матиас весьма
   [заинтересован][mattias-wish] в разработке этой фичи, так что возможно ее появление в следующих релизах.

[backtracking]: https://en.wikipedia.org/wiki/Backtracking
[mattias-wish]: https://groups.google.com/d/msg/parboiled-user/b7PH49fiFco/gGt46xe3Ae4J


# Подготовительные работы
Перед началом работы с библиотекой добавим её в classpath. В Maven, например, это делается так:

    <dependency>
        <groupId>org.parboiled</groupId>
        <artifactId>parboiled_2.11</artifactId>
        <version>2.1.0</version>
    </dependency>

Я использую Scala 2.11, однако существуют артефакты и для 2.10.


# Язык описания правил (Rule DSL)
Вся функциональность Parboiled реализуется поверх синтаксиса языка Scala при помощи специализированного EDSL.
Поэтому описание парсера на самом деле есть ни что иное, как объявление класса, производного от `org.parboiled.Parser`.
В качестве примера напишем шаблон парсера, который не выполняет каких-либо полезных действий.

    import org.parboiled2._

    class myparser(val input: parserinput) extends parser {
      // здесь описана ваша грамматика
    }

Конструкции dsl и ряд полезных классов добавляются в зону видимости всего одной директивой импорта. хочу отметить, что
наличие параметра `input` в конструкторе является обязательным: это означает, что для каждого нового набора входных
данных нужно создавать новый объект-парсер.


## Правила для отдельных символов
Итак, когда шаблон парсера у нас уже имеется, следует добавить в него несколько правил, в соответствии с которыми он
и будет обрабатывать данные. Если вы работали с Parboiled1, этот раздел можно просто пролистать, так как мои объяснения
могут показаться вам излишне подробными.

Начнем с терминалов. Этот термин будет использоваться в дальнейшем, поэтому попробуем дать ему здесь неформальное
определение:

> Терминал — это простейшее атомарное правило, не требующие дополнительных определений

Давайте опишем два простейших правила: первое должно распознать некоторый наперёд известный символ, второе — строку:

    def MyCharRule   = rule { ch('a') }
    def MyStringRule = rule { str("string") }

Каждый раз обозначать свои намерения подобным образом весьма утомительно. И здесь нам на помощь приходит механизм
неявных преобразований (implicit conversions), который позволяет сделать правила короче:

    def MyCharRule   = rule { 'a' }
    def MyStringRule = rule { "string" }

Строки сопоставляются с точным учётом регистра символов. Тем не менее, существует множество языков, не чувствительных к
регистру (например SQL). Для них существует правило `ignoreCase`, сопоставляющее входную строку независимо от ее
регистра. Передаваемая в него строка обязательно должна быть в нижем регистре:

    def StringWithCaseIgnored = rule { ignoreCase("string") }

Подробнее о правилах или «продукциях» будет рассказано в последующих разделах. Все приведенные выше (и ниже) правила
имеют тип `Rule0`. Правила бывают разных типов, но сейчас нам необходимо знать лишь то, что `Rule0` обозначает, что
правило сопоставляет с собой входную строку и говорит, совпало или нет. Мы не указали тип потому, что механизм вывода
типов языка пока легко справляется и сам. Однако, ничто не мешает нам указать тип явно:

    def StringWithCaseIgnored: Rule0 = rule { ignoreCase("string") }

В Parboiled существуют особенные терминалы (они же синтаксические предикаты):

  - `ANY` — любой символ, кроме `EOI`.
  - `EOI` (End of Input) — виртуальный символ-маркер конца ввода, который вы обязательно захотите добавить в главное
    правило своего парсера. Определяется `EOI` так:

        val EOI = '\uFFFF'

Несмотря на то, что символ U+FFFF зарезервирован для внутреннего использования стандартом Unicode, на практике он может
запросто встретиться в пользовательском вводе и изменить поведение парсера. Поэтому будьте внимательны с текстом,
который попадает на вход.

Кроме того, если вы не добавите `EOI` в конце главного правила и при сопоставлении возникнет ошибка, то о ней вы не
узнаете, так как парсер будет считать, что входные данные ещё не закончились и будет ожидать поступления новых данных.
Поэтому, что бы вы не подали на вход, на выходе вас ожидает бессмысленный Success(()).

Из правил `chr` и `str` вряд ли можно составить полезный парсер, поэтому первым шагом к осмысленности станет
возможность определять *диапазон* допустимых симовлов. В Parboiled2 это делается очень легко:

    def Digit      = rule { '0' - '9' }
    def AlphaLower = rule { 'a' - 'z' }

Оба эти правила сопоставят за раз максимум один символ из диапазона (или не сопоставят ни одного). Хотя написать
конкретно эти два правила в PB2 очень просто, делать это нет необходимости: они уже определены в объекте
`CharPredicate`. Parboiled1, напротив, заставлял вручную создавать эти правила, практически каждый раз, когда вы пишете
очередной парсер. Поэтому я носил свою библиотечку примитивов из проекта в проект (уверен, что не я один так делал).
Теперь моя библиотечка заметно подыстощилась благодаря появлению `CharPredicate`. В него входят, например, следующие
правила (думаю, что из названий будет понятно, каким категориям символов они соответствуют):

 - `CharPredicate.All` (работает почти так же, как `ANY`, но показывает худшую производительность на больших диапазонах
   символов);
 - `CharPredicate.Digit`;
 - `CharPredicate.Digit19`;
 - `CharPredicate.HexDigit` и много других правил.

Если вас не устраивают имеющиеся правила, вы всегда сможете определить свой собственный символьный предикат, для этого
необходимо использовать метод `from`:

    CharPredicate from (_.isSpaceChar)

Кроме того, для символьных предикатов определены операторы `except` (`--`) и `union` (`++`), которых не было в PB1.
Лично я от этого отсутствия очень страдал: приходилось замыкать правило «с другой стороны», перечисляя полностью черный
или белый список символов в зависимости от ситуации. Правило `--` можно так же назвать разностью, так как роль у него
такая же, что и у [разности двух множеств][substract].

[substract]: https://ru.wikipedia.org/wiki/Разность_множеств

    // Сопоставит любой печатный символ, если это не кавычка.
    def AllButQuotes = rule { CharPredicate.Visible -- "\"" -- "'" }

    // Неплохо подойдет для определения идентификатора. Обратите внимание, как
    // AlphaNum объединяется с нижним подчеркиванием.
    def ValidIdentifier = rule {
      CharPredicate.Alpha ~ zeroOrMore(CharPredicate.AlphaNum ++ "_") }

Полезно будет знать ещё о двух правилах: `anyOf` и `noneOf`. Они очень похожи на `except` и `union`, но работают
на всём пространстве символов `ANY`. И самое главное: в этом пространстве они работают быстрее. Эти функции могут
принимать на вход строку, состоящую из перечислений символов. Например:

    // Определит, является ли символ одной из арифметических операций.
    def ArithmeticOperation = rule { anyOf("+-*/^") }

    // Сопоставит всё, кроме перечисленных пробельных символов и EOI.
    def WhiteSpaceChar = rule { noneOf(" \t\n") }

Иногда возникает вопрос, что же выбрать: `anyOf`/`noneOf` или `CharPredicate`? Заранее предопределенный символьный
предикат будет работать быстрее для 7-битных символов ASCII. «Заранее предопределенный» написано не просто так, и в
разделе «Best Practices» части 4 будет рассказано, почему. Однако для очень больших символьных диапазонов
`CharPredicate` ведёт себя откровенно плохо, и тогда на помощь должны прийти `anyOf` и `noneOf`.


## Цепочки правил

### N.times
Сопоставлять единичные символы не интересно, поэтому перейдем к более сложным правилам. Начнём с `times`, которое
позволяет сопоставить одно правило несколько раз подряд. Количество повторений должно быть точным и заранее известным.

    def BartLearningParboiled = rule {
      100 times "I will never write a parser again. "
    }

Некоторые грамматики требуют жесткого диапазона числа повторений, например [от двух до пяти][korn]. В новом Parboiled
это можно легко устроить:

    def FutureOfCxx = rule { 'C' ~ (2 to 5).times('+') }

[korn]: http://www.chukfamily.ru/Kornei/Prosa/Ot2do5/Ot2do5.htm

А в старом — существует правило `nTimes`, которое, требует указания точного числа повторений. В случае, если точное
количество повторений заранее не известно, вам помогут следующая пара правил.

### zeroOrMore
Как вы уже наверное догадались из названия, zeroOrMore сопоставляет последовательность из нуля и более вхождений
указанного правила. Внимательный читатель уже заметил это правило в примерах и оно ему, скорее всего, показалось хорошо
знакомым: в регулярных выражениях точно такая же операция обозначается звёздочкой, а любители академической
терминологии, кроме того, знают, что она называется [звездой Клини][kstar]. В любом случае, использовать это правило
очень просто:

    def Whitespace = rule { anyOf(" \n\t") }
    def OptWs      = rule { zeroOrMore(Whitespace) }

[kstar]: https://ru.wikipedia.org/wiki/%D0%97%D0%B2%D0%B5%D0%B7%D0%B4%D0%B0_%D0%9A%D0%BB%D0%B8%D0%BD%D0%B8


### oneOrMore
Правило, похожее на предыдущее. Оно делает почти то же самое, что и `zeroOrMore`, но требует, чтобы по крайней мере
одно повторение присутствовало во входных данных. Идентично плюсу Клини для регулярных грамматик.

    def UnsignedInteger = rule { oneOrMore(CharPredicate.Digit) }


### Разделитель цепочек: separatedBy

Часто приходится иметь дело со случаем, когда множество элементов записывается подряд через некоторый разделитель:
это и CSV, и определения списков или массивов, и перечисления аргументов функции через запятую, и многое другое.
В Parboiled2 парсинг таких последовательностей делается легко и непринужденно:

    def CommaSeparatedNumbers = rule { oneOrMore(UnsignedInteger).separatedBy(",") }

Однако, первая версия использует для этого менее элегантный синтаксис:

    def CommaSeparatedNumbers = rule { oneOrMore(UnsignedInteger, separator = ",") }


### Оператор последовательности (~)
Для того чтобы указать последовательность правил используется оператор `~`. В регулярных выражениях нет необходимости
в подобном операторе, там этот факт записывается непосредственным образом, так же, как и в некоторых вариантах BNF. Для
примера напишем (предельно упрощенное) правило которое сопоставляет дату определенного формата:

    import CharPredicate.Digit

    // Дата должна иметь следующий формат: "yyyy-mm-dd"
    def SimplifiedRuleForDate = rule { Year ~ "-" ~ Month ~ "-" ~ Day }

    def Year  = rule { Digit ~ Digit ~ Digit ~ Digit }
    def Month = rule { Digit ~ Digit }
    def Day   = rule { Digit ~ Digit }

Как видите, правило максимально упрощено, и я прекрасно отдаю отчет тому, что у нас может быть 99 дней и 99 месяцев.
Не все проверки имеет смысл оставлять на уровне парсера: мы всё равно передадим сопоставленную строку на вход
какому-нибудь классу для работы с датой и временем, который догадается выполнить валидацию, и вернет результат,
обернутый в Option. А вот грамматику этим мы заметно упростим. Попытка заставить парсер выполнить все возможные и
невозможные проверки часто приводит к [подобным результатам][re-email].

[re-email]: http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html


### «Необязательное» правило (optional)
Если бы существовало правило `zeroOrOne`, то это и был бы `optional`: либо есть одно вхождение, либо вхождений нет
совсем. Давайте разберем следующий пример: в разных семейства операционных систем маркер конца строки кодируется
по-разному. Например, в Unix-подобных операционных системах нужен только символ `\n`, тогда как в Windows исторически
используется последовательность из двух символов: `\r` и `\n`. И если мы хотим обрабатывать текст, созданный в
любой из этих систем, то можно использовать следующее правило для конца строки:

    def Newline = rule { optional('\r') ~ '\n' }


### Упорядоченный выбор (|)
Аналог оператора `|` в регулярных выражениях, неспроста называемый *упорядоченным* выбором (ordered choice).
Предположим, что нам нужно распознать число, у которого может быть знак, а может, и не может. Знак, если он есть,
может быть двух типов: положительный и отрицательный, разберемся сначала с ним:

    def Signum = rule { '+' | '-' }

Знак может вовсе отсутствовать в записи положительного числа:

    def MaybeSign = rule { optional(Signum) }

Тогда само число в любом случае представится в виде последовательности из возможного вхождения знака числа и его
модуля — числа без знака:

    def Integer = rule { MaybeSign ~ UnsignedInteger }

Порядок перечисления вариантов в правиле `Signum` имеет значение: выбирается самый первый из подошедших вариантов, что
исключает возможность появления неоднозначности у грамматики. И да, так работают все без исключения PEG-парсеры.
Так что, если вам нужно разобрать выражение на языке C, начинать перечисление нужно с самых длинных операций, чтобы
они сопоставились первыми, как и предписывает стандарт. Упрощённо правило может выглядеть, например, так:

    def Operator = rule {
      "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "^=" | "|=" | "<<=" | ">>=" |
      "<<" | ">>" | "<=" | ">=" | "==" | "!=" |
      "||" | "&&" | "->" | "++" | "--" |
      "<"  | ">"  | "+"  | "-"  | "&"  | "|" | "." |
      "*"  | "/"  | "!"  | "~"  | "^"  | "=" | ","
    }

Порядок перечисления может быть самым различным, но нужно обеспечить, чтобы в нём `+` всегда шёл после `+=` и `++`,
а `<` — после `<=` и `<<` (а `<<`, в свою очередь, после `<<=`). В противном случае может случиться, что составной
оператор присваивания `<<=` распарсится в последовательность [`<=`, `=`], а то и вовсе [`<`, `<`, `=`].

Если правило выбора становится избыточно сложным и нам не хочется полагаться на порядок его элементов, стоит
сгруппировать их по общим префиксам (факторизовать парсер):

    def Operators = rule {
      ("+" ~ optional("=" | "+")) |
      ("<" ~ optional("=" | ("<" ~ optional("=")))) | ...
    }

Заметим, однако, что ни один из наших примеров не сможет автоматически учитывать приоритеты операторов, для этого
придётся прибегнуть к более изощренным правилам.


### Немного сахара
Для `optional`, `oneOrMore` и `zeroOrMore` существует синтаксический сахар, позволяющий сделать определения ещё короче:
`.?`, `.+` и `.*`. Пожалуйста, используйте их мудро: при злоупотреблении ими, ваши правила будут читаться немногим
лучше, чем регулярные выражения. С помощью этих «ярлыков» мы можем сделать описание наших правил менее многословным:

    import CharPredicate.Digit
    def SignedInteger   = rule { (+ | -).? ~ Digit.+ }

    def Newline = rule { '\r'.? ~ '\n' }

    def OptWs = rule { WhitespaceChar.* }


### Запуск парсера
Для того, чтобы заставить написанный парсер сделать хоть что-то полезное, нужно вызвать метод `run` его главного
(корневого) правила. Если вы пишете модульный-тест для парсера, то возможно, имеет смысл вызывать этот метод и для
других правил. Скобочки после метода при этом обязательны.

Давайте заставим работать наш бесполезный парсер, умеющий сопоставлять только одну строковую константу. Итак
наш парсер определён следующим образом (не забываем про `EOI`):

    import org.parboiled2._

    class MyParser(val input: ParserInput) extends Parser {
      def MyStringRule: Rule0 = rule { ignoreCase("match") ~ EOI }
    }

Теперь где-нибудь в другом месте создадим несколько экземпляров парсеров и подадим им на вход разные данные:

    val p1 = new MyParser("match")
    val p2 = new MyParser("Match")
    val p3 = new MyParser("much")

    // по-умолчанию возвращают scala.util.Try
    p1.MyStringRule.run()      // Success
    p2.MyStringRule.run()      // Success
    p3.MyStringRule.run()      // Failure

Прогон правил в Parboiled2 намного проще, чем в Parboiled1, для которого существует целый зоопарк раннеров (parser
runners), которые приходится дополнительно вызывать. За более подробной информацией прошу в раздел «Отчеты об ошибках»
части 4.


### Вложенные структуры данных
Разбор рекурсивных структур — это то, что может Parboiled и не могут регулярные выражения. В Parboiled это получается
естественно и непринужденно, что мы и продемонстрируем на последующих примерах. Единственное дополнительное
усилие, которое от вас требуется — явно объявить тип правил, участвующих в рекурсии.

Разбор рекурсивных структур обычно иллюстрируют на примере калькулятора арифметических выражений. По моему мнению,
пример совершенно не нагляден. Поэтому мы рассмотрим вымышленный формат конфигурационных файлов, состоящий из
именованных блоков, которые содержат пары «ключ—значение».


# Формат BKV (Block-Key-Value)
В качестве примера будет использоваться формат «BKV», который был придуман специально для этого туториала. Он
вдохновлялся форматом [HOCON][hocon] и, собственно, является его подмножеством. BKV состоит из пар ключ—значение и
блоков, внутри которых могут размещаться пары. Выглядит это примерно так:

[hocon]: https://github.com/typesafehub/config/blob/master/HOCON.md

    server.name = "webserver"
    server {
      port    = "8080"
      address = "192.168.88.88"

      settings {
        greeting_message = "Hello!\n It's me!"
      }
    }

Как видите, формат прост и незатейлив, хотя строки с экранированием (escaping) могут напугать тех, кто никогда не
писал парсеры. Экранирование очень часто встречается при синтаксическом разборе, поэтому мы обязательно и в
подробностях его рассмотрим.


## Экранированные строки
Для того, чтобы при синтаксическом разборе не иметь проблем с пробельными и непечатными символами в большинстве
грамматик строки заключаются в двойные или одинарные кавычки (или их некое подобие, например, могут использоваться
открывающие и закрывающие угловые скобки). Непечатные символы и кавычки — экранируются.

Для того, чтобы написать распознаватель экранированных строк, необходимо определиться со следующими элементами
синтаксиса:

 - Символы, открывающие и закрывающиие строку (в нашем случае это один и тот же символ — двойная кавычка).
 - Символ экранирования (в нашем случае это символ обратного слеша).
 - Набор символов-мнемоник для обозначения непечатных символов
 (мы будем поддерживать, как минимум, `'\n'`, `'\t'` и `'\v'`).

Сначала попробуем описать правило для квотированной строки без экранирования:

    def OverlySimplifiedQuotedString = rule {
      '"' ~ zeroOrMore(AllowedChar) ~ '"'
    }

Поскольку пустые строки тоже возможны, между кавычками мы используем правило `zeroOrMore`. Очевидно, что двойная
кавычка в перечень допустимых символов не входит. Что же тогда разрешено? Всё, что не запрещено. Поэтому для нашего
случая список разрешенных символов выглядит так:

    def AllowedChar = rule { noneOf("\"") }

Без двойной кавычки жить можно, но сложно. Но что будет, если мы добавим кавычку внутрь строки? Встретив её, парсер
подумает, что строка закончилась, и взорвётся сообщением об ошибке на следующем же символе.

Символ экранирования предупреждает парсер о том, что следующий символ особенный. Алгоритм выглядит таким образом: парсер
ожидает один из разрешенных символов или экранированную последовательность, а экранированная последовательность состоит
из символа экранирования и следующего за ним оператора выбора одного из символов:

    def AllowedChar = rule {
      noneOf("\"\\") | EscapeSequence
    }

    // Поддерживаются последовательности: \", \\, \n, \a, \f, \v.
    def EscapeSequence = rule {
      '\' ~ anyOf("\"\\nafv")
    }

Разобравшись, как это работает, можно переходить к написанию финального варианта правил для экранирования. Для этого
предлагаю создать выделенный трейт:

    import org.parboiled2._

    object QuotedStringSupport {
      val CharsToBeEscaped = "abfnrtv\\\""
      val Backslash = '\\'
      val AllowedChars = CharPredicate.Printable -- Backslash -- '"'
    }

    trait QuotedStringSupport { this: Parser =>
      import QuotedStringSupport._

      def QuotedString: Rule0 = rule {
        '"' ~ QuotedStringContent  ~ '"'
      }

      def QuotedStringContent: Rule0 = rule {
        oneOrMore(AllowedChars | DoubleQuotedStringEscapeSequence)
      }

      def DoubleQuotedStringEscapeSequence = rule {
        '\\' ~ anyOf(CharsToBeEscaped)
      }
    }

Теперь, когда мы разобрались со строками и выделили соответствующую функциональность в отдельный трейт, перейдем к
самому формату.

## Вспомогательные терминалы
В написании парсеров существует два подхода: «от общего к частному» и «от частного к общему». Обычно грамматики
описываются согласно первому, но это всего-лишь туториал, поэтому начнем с деталей помельче, а затем обобщим.

Начем описание со вспомогательных элементов, а именно, с пробелов. В нашем случае пробелами будут являться символы:
' ', '\n' и '\t'. Конечно же, пробельных символов в природе существует куда больше, но в примере мы ограничимся тремя.
Разобраться с пробелами можно разными способами:

 - перечислить символы через оператор упорядоченного выбора;
 - объявить свой `CharPredicate`, содержащий эти три символа;
 - использовать `anyOf`.

Мы воспользуемся последним. При этом учтём, что в некоторых местах пробелов может быть несколько, в других — не
быть вовсе, а кое-где пробелы должны быть обязательно (но нашему формату обязательные пробелы не требуются):

    val WhitespaceChars = "\n\t "
    def WhiteSpace = rule { anyOf(WhitespaceChars) }
    def OptWs      = rule { zeroOrMore(WhiteSpace) }

Правило, описывающее перевод строки мы объявляли ранее:

    def Newline = rule { optional('\r') ~ '\n' }

Ключ и имя блока представляют собой идентификатор, похожий на тот, что вы можете встретить в различных языках
программирования. Идентификатор должен начинаться либо с буквы английского алфавита (регистр не имеет значения),
либо с символа нижнего подчеркивания. В середине может содержать цифры а так же буквы английского алфавита (строчные и
заглавные). Вхождение точки, в середине идентификатора тоже допустимо. Перед тем как объявлять ключ, объявим правило,
описывающее идентификатор. (Аналогичные правила будут применяться для имени блока). Нам необходимо два символных
предиката: для первого и последующих символов.

    // Первый символ идентификатора
    val IdentifierFirstChar = CharPredicate.Alpha ++ '_'

    // Для последующих символов
    val IdentifierChar      = CharPredicate.AlphaNum ++ '.' ++ '_'

Объявим также символы начала и конца блока:

    val BlockBeginning  = '{'
    val BlockEnding     = '}'

Теперь, когда у нас имеются все необходимые вспомогательные терминалы, займёмся блоками покрупнее.


## Пары ключ—значение
Теперь перейдём к синтаксису пар «ключ–значение». Потребуем, чтобы ключ представлял собой валидный идентификатор, как
описанно выше, а значение было квотированной строкой, как тоже описано выше. Итак, начнем с определения идентификатора:

    def Identifier = rule {
      IdentifierFirstChar ~ zeroOrMore(IdentifierChar)
    }

Возможно, нам не стоило задавать идентификатор достаточно жестким правилом, однако в большинстве грамматик с которыми
вам, скорее всего придется столкнуться, используются аналогичные правила. Например, идентификаторам запрещено начинаться
с цифры, ввиду наличия целочисленных литералов, различные символы могут являться валидными операторами. Правило
описывающее ключ, будет выглядеть так:

    def Key = rule { Identifier }

Для описания значения воспользуемся уже имеющимся правилом (для этого нам всего-то нужно подмешать написанный нами
ранее трейт):

    def Value = rule { DoubleQuotedString }

Теперь опишем правило для всей пары целиком. Тут стоит еще раз напомнить о том, что Parboiled является PEG, из этого
следует, что нам постоянно нужно помнить о пробелах и сообщать правилу о местах, где они могут встречаться.

    def KeyValuePair = rule { Key ~ OptWs ~ "=" ~ OptWs ~ Value }


## Вложенные блоки
Блок ограничен фигурными скобками и может содержать внутри как пары «ключ—значение», так и другие блоки. Поэтому для
начала нужно стереть различия между блоками и парами ключ—значение, обозвав и те, и другие узлами (nodes)
синтаксического дерева. Это делается следующим кодом:

    // Тип правила обязателен к указанию, иначе не взлетит!
    def Node: Rule0 = rule { KeyValuePair | Block }

Так как и блок, и корневая структура состоят из списка узлов, нам нужно объявить правило для этого списка:

    def Nodes = rule {
      OptWs ~ zeroOrMore(Node).separatedBy(Newline ~ OptWs) ~ OptWs
    }

Опциональные пробелы могут быть и перед списоком нод, и после него, и между отдельными его элементами, поэтому у нас в
правиле получилось так много вхождений `MaybeWs`. Теперь определим имя блока — это всё тот же идентификатор, что
используется и в имени ключа:

    def BlockName = rule { Identifier }

Наконец, всё необходимое для объявления блока целиком у нас есть, поэтому объявим блок:

    def Block = rule { BlockName ~ "{" ~ Nodes ~ "}" }

Помните мы определяли `BlockBeginning` и `BlockEnding`? Используем их в объявлении:

    def Block = rule { BlockName ~ BlockBeginning ~ Nodes ~ BlockEnding }

Заметьте, что `Block` ссылается на правило `Nodes`, которое будет ссылаться на правило Node. Node может ссылаться как на
правило Block, из-за чего возникает цикл. Поэтому нам необходимо явно указать тип правила, успокоив Parboiled. Так как
мы пишем распознаватель, тип правила всегда будет Rule0.

Итак, у нас всё есть, не хватает только точки входа, или корня (root), который тоже представляет собой ни что иное, как
список узлов, для которого у нас уже есть готовое правило. Используем его, не забыв учесть возможные пробелы и завершить
правило символом `EOI`:

    def Root: Rule0 = rule { Nodes ~ EOI }


# Стек значений (Value Stack)
Прежде чем извлекать какие-либо данные при помощи правил, следует немного рассказать про одну из концепций,
которая реализована в Parboiled. Она называется Value Stack и ее можно не совсем корректно перевести как
«стек значений». Представляет он собой, действительно, стек, который модифицируется *действиями парсера*
(parser actions), в него помещаются и из него извлекаются результаты парсинга правил. Именно этому стеку мы должны дать
подсказку при объявлении рекурсивных правил. Для того, чтобы элементы были помещены на стек, их необходимо явно
захватить, что отразится на виде ваших правил. Типы правил также отражают количество захваченных элементов и их тип.
Элементы стека могут иметь разный тип, а типизация стека значений проверяется на этапе компиляции.


# Типы правил
В Parboiled2 существуют следующие типы правил:

 - `Rule0` — просто отвечает на вопрос "Сопоставилось ли?", не изменяя содержимое стека.
 - `Rule1` — помещает один объект в стек значений.
 - `Rule2` — помещает два объекта в стек значений.
 - `RuleN` — помещает N объектов в стек значений, используя семантику библиотеки Shapeless. Для работы с Parboiled2
   знать Shapeless не нужно (хотя и будет полезно).
 - `PopRule` — извлекает значения со стека, не помещая туда новых значений.

При желании можно объявить свои псевдонимы для типов, как это было в Parboiled1. Так, например, в коде Parboiled2
реализуется `Rule2`:

    type Rule2[+A, +B] = RuleN[A :: B :: HNil]

В Parboiled1 для каждого количества аргументов от 0 до 7 существовал отдельный тип, что создавало так называемую
«проблему `Rule7`»: класса `Rule8` уже нет и положить восемь элементов в стек значений не получится, даже если очень
хочется. Существуют различные пути для обхода этой проблемы, и про один из них я расскажу в далее в статье.


# Действия парсера (parser actions)
Действия парсера стоило бы назвать действиями над стеком, так как они позволяют извлекать данные из сопоставившихся
правил, преобразовывать их, а при условии высокой степени вашей испорченности — производить с ними сайд-эффекты
(что может в некоторых случах быть действительно необходимым, например, если размер и количество извлекаемых данных
заранее не известны). С помощью действий можно формировать абстрактные синтаксические деревья ([AST][ast]), их
можно использовать для вычисления «на месте», как это сделано в [примере с калькулятором](calc).

[ast]: https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево
[calc]: https://github.com/sirthias/parboiled2/tree/master/examples/src/main/scala/org/parboiled2/examples


# Захват значений
Чтобы совершить какое-то полезное дейстие над данными, нам надо их сначала захватить. Для этого существует
функция `capture`: она сопоставляет данные с правилом и в случае успеха помещает их на стек значений.

Предположим у нас есть правило типа `Rule0`, из которого мы хотим хоть что-то вытащить:

    def User: Rule0 = rule { FirstName ~ Separator ~ LastName }

Нам нужно решить, что именно мы будем захватывать, хоть и очевидно, что разделитель не представляет для нас ценности:

    def User: Rule2[String, String] = rule {
      capture(FirstName) ~ Separator ~ capture(LastName)
    }

С этого момента наше правило уже не `Rule0`, а `Rule2`, так как оно захватывает и оправляет в стек значений две
строки. Впрочем, тип можно и не указывать, компилятор все поймет сам.


## Оператор действия ~>
Оператор, которым вам придется пользоваться чаще всего. В качестве правого параметра принимает лямбду, на вход
которой отправляет захваченные со стека объекты — тем самым позволяя лямбде с этими объектами работать. Потом,
при желании, значения можно отправить обратно в стек, или же создать из них узел для вашего AST — выберите по своему
вкусу. В любом случае, для того, чтобы действие осуществилось, нужно предварительно выполнить захват данных на стек при
помощи функции `capture`. В зависимости от типа возвращаемого значения используются различные формы оператора `~>`,
что делает использование данного оператора простым и интуитивным.

> В Parboiled1 захват выполнялся неявно, что я нахожу весьма неудобным.

Теперь немного подробнее про лямбду. Ее сигнатура зависит от количества и типизации захваченных объектов, причем за раз
лямбда может захватить [не более 22 аргументов][lambda22]. Типы аргументов лямбды соответствуют типам значений,
снимаемых со стека, а типы возвращаемых значений — типам значений, помещаемых назад в стек.

[lambda22]: https://github.com/sirthias/parboiled2/issues/85

Для примера попробуем извлечь у парсера хотя бы одно целое число:

    def UnsignedInteger: Rule1[Int] = rule {
      capture(Digit.+) ~> (numStr => numStr.toInt)
    }

В этой ситуации поощряется использование фирменного скаловского плейсхолдера:

    def UnsignedInteger: Rule1[Int] = rule {
      capture(Digit.+) ~> (_.toInt)
    }

Здесь лямбда имеет тип `(String => Int)`, что обуславливает тип нашего правила - `Rule1[Int]`. Позволяется
применять оператор `~>` и к типизированному правилу, например, следующее правило сопоставляет целое число, но поместит
в стек не его, а его удвоенное значение:

    def TwoTimesLarger = rule { UnsignedInteger ~> (i => i * 2) }

Тип правила `TwoTimesLarger` так и останется `Rule1[Int]`, только на стеке будет лежать другое значение.

> Явное указание типа аргументов лямбда-функции не самая лучшая идея (по крайней мере, на момент написания статьи).
> В компиляторе Scala существует весьма неприятный баг, который не даст вашему коду нормально скомпилироваться.

С одним аргументом мы разобрались, но что делать, если их несколько? Как поведет себя лямбда? Просто и предсказуемо:
первый параметр соответствует самому верхнему значению на стеке, второй параметр — второму сверху, и так далее.
Так как процедура захвата подвыражений выполняется *справа налево*, то порядок аргументов лямбда-функции соответствует
порядку записи операций захвата:

    def UserWithLambda: Rule2[String, String] = rule {
      capture(FirstName) ~ Separator ~ capture(LastName) ~> ((firstName, lastName) => ...)
    }

Благодаря оператору действия мы можем уменьшать количество значений на стеке:

    def UserName = User ~> ((firstName, lastName) => s"$firstName $lastName")

В приведенном примере исходный тип правила `User` был `Rule2[String, String]`, применив к нему лямбда-функцию мы
создали новое правило `UserFirstName` с типом `Rule1[String]`.

Лямбда не обязана принимать *все* параметры со стека, можно ограничиться последними N значениями (помним, что
лямбда забирает аргументы с конца стека):

    (foo: Rule2[Int, String]) ~> (_.toDouble)
    // foo: Rule2[Int, Double].

Ничего не мешает нам попробовать скормить правилу лямбда-функцию, не имеющую аргументов, с предсказуемым результатом:

    (foo: Rule0) ~> (() => 42)
    // foo: Rule1[Int].

У Parboiled2 есть более мощные инструменты, например, возможность вернуть из лямбды на стек сразу группу значений:

    (foo: Rule1[Event]) ~> (e => e::DateTime.now()::"localhost"::HNil)
    // foo: RuleN[Event::DateTime::String::HNil]

Фактически мы конструируем фирменный шейплессовский `HList`. Тип результирующего правила будет
`RuleN[Event::DateTime::String::HNil]`.

Аналогично можно забирать значения со стека значений, ничего не отдавая взамен: для этого лямбда всего-навсего должна
«возвращать» тип `Unit`. Типом получившегося правила, как вы наверное догадались, будет `Rule0`:

    (foo: rule1[String]) ~> (println(_))
    // foo: Rule0

Кроме того, оператор действия предлагает особо сладкий сахар для case-классов:

    case class Person(name: String, age: Int)

    (foo: Rule2[String, Int]) ~> Person
    // foo: Rule1[Person]

Правда нужно отметить, что компилятор может и не переварить этот сахар, если для case-класса определен companion object.
Тогда придется добавить лямбду, немного подчеркиваний и записать: `~> (Person(_, _))`.

Сахар для case-классов идеально подходит для построения AST, опытные пользователи могут даже заметить, что в этом случае
он работает совершенно аналогично оператору `~~>` из Parboiled1. Существуют и другие способы применения `~>` , но о
них вы узнаете не от меня, а из документации. Отмечу только, что оператор `~>` реализуется в коде Parboiled2 весьма
нетривиальным образом, но как бы сложно не выглядело его определение, пользоваться им одно удовольствие. Пожалуй,
самое лучшее техническое решение, принятое на этапе создания DSL.


## run
Особая версия оператора действия. Для программиста во многих отношениях `run` ведет себя точно так же, как и `~>`,
кроме того маленького неудобства, когда в случае с `run` компилятор не выводит типы автоматически и их приходится
обозначать явно. Оператор является очень удобным средством для создания непроверяемых сайд-эффектов, например как здесь:

    def RuleWithSideEffect = rule {
      capture(EmailAddress) ~ run { address: String => send(address, subj, message) } ~ EOI
    }

Типом результирующего правила будет `Rule0`, а сопоставленная строка оказывается никому не нужна и ни в какой стек
значений не попадет, что иногда бывает необходимо. Пользователи Parboiled1 наверное заметили, что в описанном выше
контексте, `run` ведет себя так же, как оператор `~%`.

> **Предупреждение:** При использовании сайд-эффектов, не стоит злоупотреблять прямыми операциями над стеком значений.
> Да, к нему можно получить прямой доступ, но по ряду причин этого лучше не делать.


## push
Функция `push` помещает данные на стек значений в случае, если соответствующее ему правило сопоставилось. На практике
мне не приходилось пользоваться им часто, так как большую часть работы может выполнить оператор `~>`, но существует
пример, в котором `push` просто блистает:

    sealed trait Bool
    case object True extends Bool
    case object False extends Bool

    def BoolMatch = rule { "true" ~ push(True) | "false" ~ push(False) }

> Хоть это нигде и не отмечено, данное правило следует семантике call-by-name и вычисляется каждый раз, а
> значит и его аргумент вычисляется каждый раз. Обычно это пагубно сказывается на производительности, поэтому `push`
> лучше использовать с константами и только c константами.

Так же как в случае с `run` и `~>`, тип значения, переданного в `push`, определяет содержимое стека и тип создаваемого
правила.


## Вложенные парсеры
В Parboiled2 существует поддежрка вложенных парсеров: захватывая текст и скармливая его оператору `~>` мы получаем
переменную строкового типа в качестве параметра лямбда функции. Проведя некоторые операции со сторокой мы можем
отправить ее на вход какому-нибудь подпарсеру и так далее. На практике применять не приходилось, но следует знать,
что такая возможность есть.


# Генерация AST
У нас есть все необходимые знания, чтобы написать свой парсер, генерирующий синтактическое дерево. Синтаксические
деревья строятся из нод. Поэтому начнем с них, вернее с их описания:

    sealed trait AstNode
    case class KeyValueNode(key: String, value: String) extends AstNode
    case class BlockNode(name: String, nodes: Seq[AstNode]) extends AstNode

Каждый из кейс классов соответствует определенному типу ноды, вроде бы все ясно и понятно. Тем не менее, давайте
постараемся найти что-то общее среди приведенных выше узлов. У каждого есть имя, просто в случае с парой ключ-значение
это ключ. Узлы между собой различать тоже как-то нужно.

    sealed trait AstNode {
      def name: String
    }

    case class KeyValueNode
    (override val name: String, value: String) extends AstNode

    case class BlockNode
    (override val name: String, nodes: Seq[AstNode]) extends AstNode

Начнем с узла для пар ключ-значение. Нам нужно захватить ключ, захватить значение и собрать это все в case
class посредством оператора `~>`. Захват мы будем делать «на месте» (в правилах для ключа и значения). И начнем мы с
ключа:

    // Можно довериться выводу типов и не указывать тип явно
    def Key: Rule1[String] = rule { capture(oneOrMore(KeySymbol)) }

Просто добавляем `capture` и все — Parboiled думает о нас. Строка будет отправлена на стек. А вот с захватом значения
ситуация сложнее. Если мы провернем операцию, аналогичную для ключа, нам придет строка с кавычками. Они нам
нужны? Поэтому захват будем делать на территории строки:

    def QuotedString: Rule1[String] = rule {
      '"' ~ capture(QuotedStringContent)  ~ '"'
    }

Для правила Value ничего делать не нужно, оно автоматически будет иметь тип Rule1 (так как тело строки было захвачено
ранее, со стека оно никуда не ушло).

> Захват `capture` нужно делать один раз. И желательно, в том правиле, где он должен был произойти

Теперь соберем case class:

    def KeyValuePair: Rule1[AstNode] = rule {
      Key ~ MayBeWS ~ "=" ~ MayBeWS ~ Value ~> KeyValueNode
    }

Используем синтаксический сахар и элегантно упаковываем полученные ключ и значение в подходящую ноду. Конечно мы
можем использовать расширенный лямбда-синтаксис и выполнить какие-либо преобразования. Но нам они не нужны.
Теперь разберемся со списком нод:

    // тип должен быть объявлен явно, даже если вы полагаетесь на компилятор
    def Node: Rule1[AstNode] = rule { KeyValuePair | Block }

Так как каждая из нод захвачена, правило `Nodes` изменений не требует, разве что стоит указать тип значения,
помещаемого на стек:

    def Nodes: Rule1[Seq[AstNode]] = rule {
      MayBeWS ~ zeroOrMore(Node).separatedBy(NewLine ~ MayBeWS) ~ MayBeWS
    }

У нас есть все для описания блочной ноды. Имя захватим на месте, аналогично правилу для ключа:

    def BlockName: Rule1[String] = rule { capture(oneOrMore(BlockNameSymbol.+)) }

Ноды уже были захвачены, поэтому просто соберем данные в case class:

    def Block: Rule1[AstNode] = rule {
      BlockName ~ MayBeWS ~ BlockBeginning ~ Nodes ~ BlockEnding ~> BlockNode
    }

Правило, которое описывает корень дерева, так же состоит из нод, поэтому можно ничего больше и не делать. И вроде бы
все работает хорошо и ничего менять не хочется, однако результат выглядит не очень красиво: у нас есть два типа нод, и
корень который представляет список нод. И третий явно лишний. Мы можем представить корень в качестве блока, с особым
именем.

    def Root: Rule1[AstNode] = rule {
      Nodes ~ EOI ~> {nodes: Seq[AstNode] => BlockNode(RootNodeName, nodes)}
    }

Какое имя выбрать? Мы можем дать блоку вполне осознанное имя, например root, но тогда нас могут ждать непредвиденные
сюрпризы, если кто-то захочет выбрать имя root. Зная что BlockName является идентификатором, который не допускает ряд
символов, можно попробовать имена вроде `"$root"`, `"!root!"` или `"%root%"`. Работать будет. Я предпочту пустую строку:

    val RootNodeName = ""

Пустая строка:

 - Удовлетворяет главному требованию — не является валидным именем блока или ключа;
 - Отлично подойдет если мы захотим расширить грамматику. Как бы мы не мучили парсер, уж что-что, а пустую строку
 пользователь точно не создаст.

Теперь у нас есть захваченные данные. Остается только выполнить прогон из корня для подходящего текста.


# DSL для работы с узлами
Получив на руки рабочий парсер, способный отдавать синтаксическое дерево, мы должны с этим деревом как-то работать.
Создание небольшого DSL значительно упрощает эту задачу. Например, нам нужно перейти к следующей ноде по имени.
Можно каждый раз писать один и тот же код, а можно сделать небольшой метод (продублированный перегруженным оператором),
способный возвращать следующую ноду. Ниже приведены основные методы необходимые для работы с AstNode. На базе которых
можно сделать много других (наиболее подходящих под ваши нужды). Если захотите, можно дать им символьные
имена и любоваться красотой полученного DSL.

    /**
     * Код имеющий крайне опосредованное отношение к parboiled
     */
    trait NodeAccessDsl { this: AstNode =>

      def isRoot = this.name == BkvParser.RootNodeName

      lazy val isBlockNode = this match {
        case _: KeyValueNode => false
        case _ => true
      }

      /**
       * В случае блокового узла возвращает список вложенных пар
       * ключ-значение
       */
      def pairs: Seq[KeyValueNode] = this match {
        case BlockNode(_, nodes) =>
          nodes collect { case node: KeyValueNode => node }
        case _ => Seq.empty
      }

      /**
       * В случае блокового узла возвращает спосок вложенных
       * блоков
       */
      def blocks: Seq[BlockNode] = this match {
        case BlockNode(_, nodes) =>
          nodes collect { case node: BlockNode => node }
        case _ => Seq.empty
      }

      /**
       * Значение в случае пары "ключ-значение"
       */
      def getValue: Option[String] = this match {
        case KeyValueNode(_, value) => Some(value)
        case _ => None
      }
    }

Хочу отметить, что лишних методов не бывает, и практически каждый раз требуются: рекурсивный поиск, возможность изменять
значения в нодах (изменяя состояние, либо используя [линзы][lenses]). Наличие разнообразных вспомогательных методов,
работающих с деревом, очень сильно упрощает жизнь.

[lenses]: http://stackoverflow.com/questions/8307370/functional-lenses


# Производительность
Parboiled2 работает быстро, но иногда он может работать еще быстрее. В этом разделе мы поговорим о доступных
микрооптимизациях. Главное при выполнении оптимизаций — своевременность. Но если есть возможность сразу написать
чуть более оптимальный код, не потеряв при этом в выразительности — этой возможностью обязательно следует
воспользоваться.

## Разворачивайте `n.times` для малых n <= 4
Вы можете выиграть в производительности, если для малых *n* вместо оператора повторения `n.times` просто соедините
несколько повторяющихся правил в цепочку. Сколько повторений имеет смысл разворачивать — зависит от обстоятельств,
но едва ли это число больше четырех.

    // Медленно
    rule { 4 times Digit }

    // Быстро
    rule { Digit ~ Digit ~ Digit ~ Digit }

Актуальность этой оптимизации [объявлена][issue-101] самим Матиасом, хотя, гипотетически, оператор `n.times`
мог бы и сам ее выполнять.

[issue-101]: https://github.com/sirthias/parboiled2/issues/101

## Ускорение операций со стеком для `n.times`
Использование подобной техники позволит вам выжать немножко производительности и при извлечении данных
со стека значений. Например, так ее можно применить к предыдущему правилу:

    def Digit4 = rule {
      Digit ~ Digit ~ Digit ~ Digit ~
        push(
          #(charAt(-4))*1000 +
          #(charAt(-3))*100 +
          #(charAt(-2))*10 +
          #(lastChar)
        )
    }

## Не пересоздавайте `CharPredicate`
Создавать свои экземпляры типа `CharPredicate` внутри блока `rule` совершенно не стоит: объект будет пересоздаваться
каждый раз, когда выполняется правило, что драматически испортит производительность вашего парсера. Поэтому, вместо
того чтобы создавать символьные предикаты каждый раз, определите их внутри вашего парсера как константу:

    class MyParser(val input: ParserInput) extends Parser {
      val Uppercase = CharPredicate.from(_.isUpper)
      ...
    }

или, что еще лучше, отправьте это объявление в объект-компаньон вашего парсера:

    class MyParser(val input: ParserInput) extends Parser {
      ...
    }

    object MyParser {
      val Uppercase = CharPredicate.from(_.isUpper)
    }

## Используйте семантические предикаты
Особенность данных правил состоит в том, что они не взаимодействуют со стеком значений. Подробно, они описаны
в документации, но вот самое главное, что вы должны о них знать:

> При использовании семантических предикатов парсер не совершает прогресса, то есть не перемещает
> свой курсор на следующий символ. Поэтому при их бездумном использовании парсер может зациклиться.

Помните пример с объявлением символьного предиката для символов верхнего регистра? Вы можете сделать тоже
самое, используя семантический предикат `test`:

    def JavaUpperCase = rule { oneOrMore(test(currentChar.isUpper) ~ ANY) }


## Используйте `ANY` там, где хотели бы видеть `CharPredicate.All`
Увы, `CharPredicate.All` работает медленно для больших диапазонов символов, `ANY` работает быстрее. Воспользуйтесь
этим знанием.

## Используйте инвертирующий предикат
Представьте, что ваш парсер должен захватывать все символы до перевода строки (для определенности, в стиле Unix).
Конечно, это можно сделать при помощи `noneOf`, но инвертирующий предикат будет быстрее:

    def foo = rule { capture(zeroOrMore(noneOf("\n"))) }

    // Быстрее?
    def foo = rule { capture(zeroOrMore(!'\n')) }

К сожалению, этот замечательно выглядящий пример зациклит, потому что парсер не будет совершать прогресса. Чтобы это
исправить, необходимо правило, передвигающее курсор парсера, но при этом не изменяющее стек. Например, вот такое:

    def foo = rule { capture(zeroOrMore( !'\n' ~ ANY )) }

Теперь правило `foo` поглотит абсолютно все, кроме `EOI` и перевода строки.


# Отчеты об ошибках
Вам скорее всего захочется работать с парсером, выдающим бессмысленные сообщения при любых некорректных входных
данных. Parboiled2 способен вполне внятно рассказывать об ошибках, если вы ему в этом поможете.

## Форматирование
В случае ошибки, парсер передаст в ваше распоряжение объект типа `ParseError`, который можно привести в читаемый вид
посредством метода `formatError`:

    val errorMessage = parser formatError error

Если форматирование по умолчанию вас по каким-то причинам не устраивает, вы можете обозначить это явным образом:

    val errorMessage parser.formatError(error, new ErrorFormatter(showTraces = true))

Если вы захотите написать свой `ErrorFormatter`, вам придется самостоятельно разобраться со структурой
класса `ParseError`, который объявлен в глубине Parboiled таким образом:

    case class ParseError(position: Position, charCount: Int, traces: Seq[RuleTrace]) extends RuntimeException

Также стоит отметить наличие нескольких схем доставки сообщений об ошибке до пользователя: по вашему желанию
`ParseError` может быть представлен не только в виде объекта `Try`, а, например, в виде полиморфного типа или
`Either`. Подробнее можно ознакомиться [здесь][delivery-schemes].

[delivery-schemes]: https://github.com/sirthias/parboiled2/blob/master/README.rst#alternative-deliveryschemes

    def Foo = rule { "foo" | fail("Неисправность!") }

## Тонкая настройка
Существует опция, позволяющая обойти встроенный механизм формирования сообщений об ошибках.
Для этого нужно использовать правило `fail` с сообщением, которое вы хотите увидеть в случае ошибки:

    def Goldfinger = rule { "talk" | fail("to die") }

Тогда при удобном случае вы получите назад свое сообщение об ошибке примерно в такой форме:

    Invalid input 'Bond', expected to die. (line 1, column 1):

## Именованные правила
Использование подобного типа правил бывает весьма полезным не только в целях отлова ошибок. Данный механизм подробно
описан в разделе «Best Practices».

## atomic
Parboiled2 генерирует парсеры, основанные на PEG. Это означает, что парсеры оперируют символами, а не строками
(как многие могли подумать), поэтому и ошибки вам будут показываться на символьном уровне. Согласитесь — сообщение
вида «У вас X, мы ожидали Y или Z» потребует больше мысленных усилий, чем «У вас XX, а мы ожидали увидеть XY или XZ».
Для того, чтобы видеть строки в отчетах об ошибках целиком, существует маркер `atomiс`, всего-то и нужно обернуть в
него правило:


    def AtomicRuleTest = rule { atomic("foo") | atomic("fob") | atomic("bar") }

Чтобы при `foxes` на входе получить

    Invalid input "fox", expected "foo", "fob" or "bar" (line 1, column 1):
    foxes
    ^

## quiet
Когда вариантов для выбора слишком много, не всегда хочется уведомлять пользователя о всех возможных альтернативах.
Например, в определенном месте ваш парсер ожидает множество пробельных символов в совокупности с неким правилом.
Для устранения избыточности в отчете, вы, возможно, захотите умолчать о пробелах. С использованием маркера `quiet`
это очень просто:

    def OptionalWhitespaces = rule { quiet(zeroOrMore(anyOf(" \t\n"))) }

Честно признаюсь — ситуаций, поощряющих использования этого правила, я не встречал. Так же, как и `atomic`, оно
подробно [описано в документации][doc-quiet].

[doc-quiet]: https://github.com/sirthias/parboiled2/blob/master/README.rst#the-quiet-marker

## Восстановление после ошибок
Практически единственный эпизод, где Parboiled1 выигрывает, а у Parboiled2 дела обстоят не очень хорошо: парсер
падает уже только от вида первой же встреченной им ошибки. Для большинства сценариев это отлично подходит:
это, например, не мешает парсить логи, текстовые протоколы, конфигурационные файлы (для ряда случаев),
однако разработчикам DSL или IDE-подобных инструментов такое положение дел будет не по душе.
[Матиас обещает это исправить][issue-42], поэтому если вам эта функциональность очень сильно нужна уже сегодня
— напишите на баг-трекер, возможно это ускорит процесс разработки.

[issue-42]: https://github.com/sirthias/parboiled2/issues/42

В Parboiled1 имеется [огромное число ParserRunnerов][runners] на все случаи жизни. Посмотрите в сторону
`RecoveringParserRunner`, если вам нужно продолжать парсинг в случае ошибок.

[runners]: https://github.com/sirthias/parboiled/wiki/Parse-Error-Handling


## Тестирование
Разработчики Parboiled используют для тестирования фреймворк [specs2][specs2], который они дополнили своим
вспомогательным классом [TestParserSpec][tps]. Он покажется неудобным тем, кто использует scalatest, но основную
его идею можно и перенять. По секрету от Матиаса, его решение не отличается особенной аккуратностью, так как
полагается на изменяемое состояние. Возможно, в будущем нас будет ждать что-то похожее на полноценный каркас
для тестирования.

[specs2]: https://etorreborre.github.io/specs2/
[tps]:    http://bit.ly/1Y5iZ9t

Правила можно тестировать как по отдельности, так и вместе. Лично я предпочитаю писать тесты не на каждое правило,
а проверять только главное правило в «особых» случаях:

> Во многих форматах, даже стандартизованных, могут встречаться весьма интересные моменты.
> Например, в BSD-подобном формате сообщений [RFC 3164][rfc3164] под число месяца *всегда* отводится две позиции,
> даже если само число имеет один разряд. Вот пример из самого RFC:
>
> > If the day of the month is less than 10, then it MUST be represented as a space and then the number. For
> > example, the 7th day of August would be represented as `"Aug  7"`, with two spaces between the `"g"` and
> > the `"7"`.

[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt

Помимо подобного рода «интересных моментов» можно отправлять на вход парсера строки с незакрытыми скобками,
недопустимыми символами, проверять порядок операций со стеком значений.

В тестировании есть еще одна тонкость, с которой вы сразу же столкнетесь. Предположим, вы хотите оттестировать
следующее правило:

    def Decimal: Rule0 = rule {
      ("+" | "-").? ~ Digit.+ ~ "." ~ Digit.+
    }

Для этого отправим парсеру заведомо некорректный ввод и будем ждать на выходе ошибку:

    // Я еще не видел десятичных дробей с двумя разделителями.
    val p = new MyParser("12.3.456").Decimal.run()  // Success(())
    p.isFailure shouldBe true  // тест упадет

Но при прогоне теста окажется, что парсер вернул удачный результат. Почему так? В нашем правиле отсутствует `EOI`, но
если если мы добавим в него `EOI`, то испортим все правила, которые используют `Decimal`. Поэтому придется
создать специальное тестирующее правило, например, при помощи хитрого механизма [мета-правил][metarule].
Давайте добавим EOI в конце нашего предыдущего примера, и убедимся в том, что парсер упал с ошибкой:

    Failure(ParseError(Position(5,1,6), Position(5,1,6), <2 traces>))

[metarule]: https://github.com/sirthias/parboiled2/blob/master/README.rst#advanced-techniques


# Недостатки Parboiled

## Parboiled2

 - Длинные, слишком общие и совершенно непонятные сообщения компилятора об ошибках. Причина связана с выполнением
   продвинутых проверок на типах, которые [обещают убрать][issue-106] в будущих версиях.

[issue-106]: https://github.com/sirthias/parboiled2/issues/106

 - Эта проблема относится больше не к Parboiled2, а к scalac. Если у лямбды, захватывающей значения со стека, явно
   (не)определены типы аргументов, то может возникнуть ошибка компиляции:

        // Может не сработать
        def MyRule = rule { oneOrMore(Visible) ~> {s => "[" + s + "]"} }

        // Скорее всего сработает
        def MyRule = rule { oneOrMore(Visible) ~> {s: String => "[" + s + "]"} }

   Что сработает, а что нет — зависит от версии вашего компилятора.

 - Многие IDE еще не научились поддерживать макровыражения, а Parboiled2 был построен не без их помощи. Поэтому
   не стоит верить подчеркиваниям вашей среды разработки. Однажды я, забыв об этом, потратил целый день на поиск
   несуществующей ошибки буквально на ровном месте.

 - Отсутствие механизма восстановления при неудачном разборе. Проектирующих предметно-ориентированные языки, или же
   тех, кто хочет использовать Parboiled2 в качестве фронтэнда к своему компилятору, это сильно разочарует. Но
   над этим [работают][issue-42]. Если вы хотите видеть эту возможность — пишите, это ускорит разработку.

 - Я думаю, что многим разработчикам своих небольших IDE и текстовых редакторов хотелось бы видеть более гибкие
   сообщения об ошибках, чем те, что предоставляются сейчас. На данный [момент][issue-96] существует всего два
   способа повлиять на них:
    - именованные правила,
    - именованные вложенные правила.

[issue-96]: https://github.com/sirthias/parboiled2/issues/96


## Parboiled1
Большинство проектов все еще написаны на Parboiled1. И вряд-ли что-то изменится резко и кардинально, особенно в
промышленной разработке. Поэтому может быть полезным знать, как научиться мириться с его недостатками, коих у
Parboiled1 немало. Помимо весьма ограниченного DSL, у Parboiled существует проблема «Rule8», которая усложняет
написание парсера для логов. Parboiled1 построен так, что на каждое правило с N элементами имеется по классу, по
аналогии со скаловскими кортежами (tuples): есть `Rule0`, `Rule1`, вплоть до `Rule7`. Этого вполне достаточно, чтобы
распарсить сложные языки программирования, такие как Java, да и вообще не вызывает существенных проблем при разборе
древовидных структур. А вот если нужно извлечь данные из линейной структуры, например, сообщения лога-файла, то в это
ограничение очень несложно упереться. Решается это использованием кортежа вместо одного результирующего правила.
Вот пример:

    def Event: Rule1[LogEvent] = rule {
      Header ~ " " ~ UserData ~ " " ~ Message ~~> {
        (header, data, message) => SyslogEvent (
          header._1, header._2, header._3, header._4, header._5, data._1, data._2, message
        )
      }
    }


# Best practices

## CharUtils
Есть один полезный объект, не затронутый в документации: [CharUtils][CharUtils]. Он содержит ряд статических методов,
способных облегчить вашу жизнь, например: изменение регистра символов, экранирование, преобразование целочисленных
значений в соответствующие им символы (строки). и др. Его использование, возможно, сэкономит ваше время.

[CharUtils]: http://bit.ly/1NJJ2kd

## Пишите модульные тесты
Одно небольшое неудачное изменение может сломать вам грамматику. Это банальный совет, которым многие пренебрегают.
Парсер не так сложно протестировать, как, скажем IO: вам не нужны Mock-объекты и другие ухищрения для этой рутинной,
но очень ценной работы. У нас была целая инфраструктура парсеров. И поверьте, первое, что я делал при поиске ошибок —
садился и писал тесты, в случае их отсутствия.

## Делайте парсеры и правила маленькими
Разделяйте ваши парсеры на подпарсеры. Каждый компонент должен делать что-то вполне определенное. Например если вы
парсите LogEvent, у которого определено поле Timestamp (особенно если этот Timestamp соответствует
какому-нибудь Rfc), то не поленитесь и вынесите его отдельно.

  - Во-первых, это уменьшит код вашего основного прасера, и сделает его нагляднее.
  - Во-вторых, это заметно облегчит тестирование. Вы покроете модульными тестами ваш подпарсер.
    А после этого приступите к разработке главного парсера

Существуют разные подходы:

 - Разбивать парсер на трейты и использовать self-typed reference (предпочитаю этот способ).
 - Объявлять парсеры как самостоятельные сущности и использовать композицию.
 - Использовать встроенный механизм для создания subParsers.

Правила должны быть максимально компактными, но не компактней. Чем меньше ваши правила, тем легче найти ошибку в
грамматике. Очень сложно понять логику разработчика, если он делает правила длинными, и при этом многократно
использует `capture`. Усугублять ситуацию может неявный захват. Указание типа правила также помогает при поддержке.


## Отправляйте case objects вместо строк в Value stack
Данный совет можно отнести и к оптимизациям, так как это заставит парсер работать быстрее.
Отправляйте в Value stack значимые объекты, а не строки. Это сделает ваш парсер быстрее, а код нагляднее.

Плохо:

    def logLevel = rule {
      capture("info" | "warning" | "error") ~ ':’
    }

Хорошо:

    def logLevel = rule {
        “info:”   ~ push(LogLevel.Info)
      | “warning" ~ push(LogLevel.Warning)
      | “error"   ~ push(LogLevel.Error)
    }


## Используйте упрощенный синтаксис для сборки объекта
Этот красивый способ появился еще в Parboiled1. Никакой магии, просто конструктор case classа вызывается неявно.
Главное, чтобы количество и тип аргументов, помещаемых на Value Stack, совпадали с сигнатурой конструктора case classа.

Плохо:

    def charsAST: Rule1[AST] = rule { capture(Characters) ~> ((s: String) => AText(s)) }

Хорошо:

    def charsAST = rule { capture(Characters) ~> AText }

## Именованные правила (named rules)
Именованные правила заметно упрощают жизнь при получении отчетов об ошибках, так как дают возможность вместо
невнятного имени правила использовать псевдоним. Или же помечать правила определенным тегом — «Это выражение»
или «Модифицирует стек». В любом случае знать о данной функции будет полезно.

Многие пользователи Parboiled1 уже полюбили эту возможность. Например разработчики Neo4J, использующие
Parboiled для разбора языка [Cypher][cypher].

[cypher]: http://neo4j.com/docs/2.2.3/cypher-introduction.html

Как это выглядит в Parboiled1:

    def Header: Rule1[Header] = rule("I am header") { ... }

В Parboiled2:

    def Header: Rule1[Header] = namedRule("header is here") { ... }

Так же есть возможность давать имена вложенным правилам:

    def UserName = rule { Prefix ~ oneOrMore(NameChar).named("username") ~ PostFix }


# Миграция
Миграция — процесс, чаще всего, несложный, но времени отнимает немало. Поэтому я постараюсь хотя бы немного
сэкономить драгоценные часы вашей жизни и описать основные подводные камни.

## Classpath
Для того, чтобы избежать конфликтов с первой версией, Parboiled2 использует classpath `org.parboiled2` (тогда
как classpath для первой версии `org.parboiled`). Мавеновский `groupId`, однако, остался старым: `org.parboiled`.
Благодаря этому, можно иметь обе зависимости в одном проекте и осуществлять постепенный переход на новую версию.
Что, кстати, работает весьма неплохо при наличии нескольких автономных парсеров. Если же ваши парсеры состоят
из множества модулей, переиспользуемых в разных местах (как это было в моем случае) — вам придется делать миграцию
сразу и для всех модулей.

## Проверка тестов
Убедитесь в наличии и работоспособности модульных тестов. Они же у вас есть? Нет? Напишите их. В процессе миграции
мне приходилось уточнять некоторые грамматики из-за того, что новый DSL стал мощнее, и нечаянные изменения ломали
грамматики. Падающие тесты экономили много времени.
С серьезными проблемами, вроде поломки всей грамматики целиком, при миграции я не сталкивался. Может быть кто-то
поделится опытом, если с ним это произошло.

## Код вокруг парсера
Теперь парсер будет пересоздаваться каждый раз, что не всегда удобно. С PB1 я очень любил создавать парсер единожды,
а потом многократно его использовать. Теперь так сделать не получится. Поэтому вам придется изменить конструктор
парсера и немного переписать использующий его код, и не бойтесь, что это ухудшит производительность.

> **Предупреждение** Parboiled1 позволяет генерировать правила во время выполнения. Поэтому если
> у вас имеется подобный парсер, то вам, скорее всего, придется его переписать: Parboiled2 использует макровыражения
> которые делают динамику весьма затруднительной, взамен давая лучшую производительность.

## Композиция
Подход к композиции элементов парсера не изменился, это хорошая новость для мигрирующих. Однако `Parser` теперь не
трейт, а абстрактный класс. Трейты (traits) — удобнейшее средство композиции програмных компонентов, в PB1 это
позволяло подмешивать `Parser` в любые модули, смешивая модули между собой. Изменение в пользу абстрактного
класса на эту возможность никак не повлияло, но теперь для этого нужно использовать
[self-typed reference][self-typed-ref]:

[self-typed-ref]: http://docs.scala-lang.org/tutorials/tour/explicitly-typed-self-references.html

    trait Numbers { this: Parser =>
      // Ваш код
    }

В качестве альтернативного способа, вы можете сделать из ваших трейтов полноправные парсеры и импортировать
из них нужные правила (как методы) в ваш основной парсер. Я, правда, все равно предпочитаю использовать
композиции трейтов, потому как нахожу их более наглядными: мне понятней видеть парсер собранный из кусков, вместо
множественных импортов.

## Избавляемся от примитивов
В процессе миграции обязательно устройте ревизию своей личной библиотеки примитивных правил: удалите все что
имеется в `CharPredicate`. Ваша библиотечка похудеет, однако не исчезнет совсем. Многие хотели бы добавить в
parboiled поддержку различных форматов дат, грамматику описывающую электронную почту, заголовки HTTP. Parboiled
просто комбинатор парсеров: он таковым был, таким и останется.


# Заключение
В этой статье я попытался рассказать вам про самый прогрессивный и перспективный инструмент парсинга,
существующий для языка scala. Сделал небольшой туториал и рассказал о проблемах, с которыми мне пришлось
столкнуться на практике. Надеюсь, что эта статья в худшем случае окажется для вас полезной, а в лучшем — станет
руководством к действию.

# Использованные источники
 - [Список рассылки проекта Parboiled][mail-list]
 - [Презентация Александра Мыльцева][myltsev-presentation] и [слайды к ней][myltsev-slides]
 - [Примеры кода из репозитория Parboiled][pb-examples]
 - [Парсер языка scala, написаный при помощи Parboiled2][scala-parser]

[mail-list]:            https://groups.google.com/forum/#!topic/parboiled-user/Ygb_M6XU5P8
[myltsev-presentation]: http://www.youtube.com/watch?v=qZg4D62K4aQ
[myltsev-slides]:       http://myltsev.name/ScalaDays2014/#/
[pb-examples]:          http://bit.ly/1H2ZQ3A
[scala-parser]:         https://github.com/sirthias/parboiled2/tree/master/scalaParser/src

