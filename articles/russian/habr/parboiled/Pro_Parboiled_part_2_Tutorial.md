# Про Parboiled
**Часть 2. Сопоставление текста**

Если вы никогда не работали с Parboiled и из предыдущей статьи так и не поняли, о чём вообще идёт речь, то в этой
статье речь пойдёт об основных правилах сопоставления символов. Все имеющиеся в PB правила в рамках этой статьи мы
рассматривать не будем — для этого есть документация, я всего лишь хочу, чтобы вы чувствовали себя уверенно с нотацией,
используемой в Parboiled.

Для закрепления знаний мы напишем простой распознаватель для несложной грамматики. Распознаватель (recognizer), а не
полноценный парсер, так как он будет только сопоставлять входной текст c описанными нами правилам (также называемым
*продукциями*), но не будет извлекать из сопоставленного текста какие-либо значения. Разпознаватель может быть полезным
и сам по себе, так как может работать в качестве валидатора: если вход оказался некорректным с точки зрения парсера, он
расскажет, что пошло не так и где. А совсем классным наш распознаватель станет тогда, когда мы узнаем, как извлекать
разобранные значения и причем тут какой-то «value stack». Ну что, поехали?

<habracut>


# Подготовительные работы

Перед началом работы с библиотекой добавим ее в classpath. В Maven, например, это делается так:

    <dependency>
        <groupId>org.parboiled</groupId>
        <artifactId>parboiled_2.11</artifactId>
        <version>2.1.0</version>
    </dependency>

Значение `artifactId` недвусмысленно содержит используемую версию языка Scala, а не самого Parboiled. Я использую
Scala 2.11, однако существуют артефакты и для 2.10.


# Язык описания правил (Rule DSL)

Вся функциональность Parboiled реализуется поверх синтаксиса языка Scala при помощи специализированного DSL.
Поэтому описание парсера на самом деле есть ни что иное, как объявление класса, производного от `org.parboiled.Parser`.
В качестве примера напишем парсер, который ничего не делает, что не мешает ему существовать и радоваться жизни:

    import org.parboiled2._

    class UselessParser(val input: ParserInput) extends Parser {
      // Kill me plz.
    }

Конструкции DSL, а так же ряд полезных класов добавляются в зону видимости всего одной директивой импорта.
Прошу заметить, что наличие параметра `input` в конструкторе является обязательным: это означает, что на каждого нового
набора входных данных нужно создавать новый объект-парсер. Вначале меня это очень сильно пугало, но я перестал бояться,
когда увидел, как быстро оно работает.


## Правила для отдельных символов

Итак, когда никчёмный парсер у нас уже имеется, нужно добавить с него несколько правил, в соответствии с которыми он
и будет обрабатывать данные. Если вы работали с Parboiled1, этот раздел можно просто пролистать, так как мои объяснения
могут показаться вам излишне подробными.

Начнем мы с терминалов. Это термин будет использоваться в дальнейшем, поэтому попробуем дать ему здесь определение (не
совсем, впрочем, строгое):

> Терминал — это правило, не требующие дополнительных определений (не определяется посредством других правил).

Давайте опишем два простейших правила: первое должно распознать некоторый наперёд известный символ, второе — строку:

    def MyCharRule   = rule { ch('a') }
    def MyStringRule = rule { str("string") }

Каждый раз обозначать свои намерения подобным образом весьма утомительно. И здесь нам на помощь приходит механизм
неявных преобразований (implicit conversions), что позволяет сделать правила короче:

    def MyCharRule   = rule { 'a' }
    def MyStringRule = rule { "string" }

Строки сопоставляются с точным учётом регистра символов. Тем не менее существует множество языков, не чувствительных к
регистру (например SQL). Правило `ignoreCase` сопоставляет входную строку вне зависимости от ее регистра. Передаваемая в
него строка обязательно должна быть в нижем регистре:

    def StringWithCaseIgnored = rule { ignoreCase("string") }

Подробнее о правилах (или «продукциях», если вам так нравится больше) будет рассказано в следующей статье. Сейчас же нам
необходимо знать, что `Rule0` сопоставляет вход с правилом и говорит, совпало или нет. Все приведенные выше (и ниже)
правила имеют тип `Rule0`. Мы его не указывали потому, что механизм вывода типов языка пока легко справляется и сам.
Однако, ничто не мешает нам указать тип явно:

    def StringWithCaseIgnored: Rule0 = rule { ignoreCase("string") }

В Parboiled существуют особенные терминалы (они же синтаксические предикаты):

  - `ANY` — любой символ, кроме `EOI`.
  - `EOI` (End of Input) — виртуальный символ-маркер конца ввода, который вы обязательно захотите добавить в главное
    правило своего парсера. Определяется `EOI` так:

        val EOI = '\uFFFF'

Несмотря на то, что символ U+FFFF зарезервирован для внутреннего использования стандартом Юникода, на практике он может
запросто встретиться в пользовательском вводе и изменить поведение парсера. Поэтому будьте внимательны с текстом,
который попадает на вход.

Кроме того, если вы не добавите `EOI` в конце главного правила и при сопоставлении возникнет ошибка, то о ней вы не
узнаете, так как парсер будет считать, что входные данные ещё не закончились и будет ожидать поступления новых данных.
Поэтому, что бы вы не подали на вход, на выходе вас ожидает бессмысленный Success.

Из правил `chr` и `str` вряд ли можно составить полезный парсер, поэтому первым шагом к осмысленности станет
возможность определять *диапазон* допустимых симовлов. В Parboiled2 это делается очень легко:

    def Digit      = rule { '0' - '9' }
    def AlphaLower = rule { 'a' - 'z' }

Оба эти правила сопоставят за раз максимум один символ из диапазона (или не сопоставят ни одного). Хотя написать
конкретно эти два правила в PB2 очень просто, делать это нет необходимости: они уже определены в объекте
`CharPredicate`.
Parboiled1 заставлял делать это часто, практически каждый раз, когда вы пишете очередной парсер. Поэтому я носил свою
библиотечку примитивов из проекта в проект (уверен, что не я один так делал). Теперь моя библиотечка заметно
подыстощилась благодаря появлению `CharPredicate`. В него входят, например, следующие правила (думаю, что из названий
будет понятно, каким категориям символов они соответствуют):

 - `CharPredicate.All` (работает почти так же, как `ANY`, но показывает худшую производительность на больших диапазонах
   символов);
 - `CharPredicate.Digit`;
 - `CharPredicate.Digit19`;
 - `CharPredicate.HexDigit` и много других правил.
 
Если вас не устаивают имеющиеся правила, вы всегда сможете определить свой собственный символьный предикат, для этого
необходимо использовать метод `from`:

    CharPredicate from (_.isSpaceChar)
  
Кроме того, для символьных предикатов определены операторы `except` (`--`) и `union` (`++`), которых не было в PB1.
Лично я от этого отсутствия очень страдал: приходилось замыкать правило «с другой стороны», перечисляя полностью черный
или белый список символов в зависимости от ситуации). Правило (`--`) можно так же назвать разностью, так как делает оно
[то же][substract].

[substract]: http://bit.ly/1GMuCh9

    // Сопоставит любой печатный символ, если это не кавычка. И будет работать
    // медленно, так как операция вычитания из множества будет выполнять каждый
    // раз когда применяется правило. Стоит вынести определение символьного
    // предиката в отдельный val.
    def AllButQuotes = rule { CharPredicate.Visible -- "\"" -- "'" }

    // Вполне себе сойдет для определения идентификатора. Обратите внимание, как
    // AlphaNum объединяется с нижним подчергиванием.
    def ValidIdentifier = rule {
      CharPredicate.Alpha ~ zeroOrMore(CharPredicate.AlphaNum ++ "_") }

Полезно будет рассказать ещё о двух правилах: `anyOf` и `noneOf`. Они очень похожи на `except` и `union`, но работают
на всём пространстве символов `ANY`. И самое главное: в этом пространстве они работают быстрее. Эти функции могут
принимать на вход строку, состоящую из перечислений символов. Например:

    // Определит, является ли символ одной из арифметических операций.
    def ArithmeticOperation = rule { anyOf("+-*/^") }

    // Сопоставит всё, кроме перечисленных пробельных символов и EOI.
    def TheCurseOf32 = rule { noneOf(" \t\n") }

Иногда возникает вопрос, что же выбрать: `anyOf`/`noneOf` или `CharPredicate`? Заранее предопределенный символьный
предикат будет работать быстрее для 7-битных символов ASCII. «Заранее предопределенный» написано не просто так, и в
разделе «Best Practices» части 4 будет рассказано, почему. Однако для очень больших символьных диапазонов
`CharPredicate` ведёт себя откровенно плохо, и тогда на помощь должны прийти `anyOf` и `noneOf`.


## Цепочки правил

### N.times

Сопоставлять единичные символы не интересно, поэтому перейдем к более сложным правилам. Начнём с `times`, которое
позволяет сопоставить вполне определённое количество идущих подряд правил.

    def BartLearningParboiled = rule {
      100 times "I will never write a parser again. "
    }

Некоторые грамматики требуют жесткого диапазона числа повторений, например [от двух до пяти][korn]. В новом Parboiled
это можно легко устроить:

    def FutureOfCxx = rule { 'C' ~ (2 to 5).times('+') }

[korn]: http://www.chukfamily.ru/Kornei/Prosa/Ot2do5/Ot2do5.htm

А в старом — существует правило `nTimes`, которое, требует указания точного числа повторений. В случае, если точное
количество повторений заранее не известно, вам помогут следующая пара правил.

### zeroOrMore

Как вы уже наверное догадались из названия, сопоставляет последновательность из нуля и более вхождений указанного
правила. Внимательный читатель уже заметил это правило в примерах и оно ему, скорее всего, показалось хорошо знакомым: в
регулярных выражениях точно такая же операция обозначается звёздочкой, а любители академической терминологии, кроме
того, знают, что она называется [звездой Клини][kstar]. В любом случае, использовать это правило очень просто:

    def Whitespace          = rule { anyOf(" \n\t") }
    def OptionalWhitespaces = rule { zeroOrMore(Whitespace) }

[kstar]: https://ru.wikipedia.org/wiki/%D0%97%D0%B2%D0%B5%D0%B7%D0%B4%D0%B0_%D0%9A%D0%BB%D0%B8%D0%BD%D0%B8


### oneOrMore

Правило, похожее на предыдущее. Оно делает почти то же самое, что и `zeroOrMore`, но требует, чтобы хотя бы одно
повторение присутствовало во входных данных. Идентично плюсу Клини для регулярных грамматик.

    def UnsignedInteger = rule { oneOrMore(CharPredicate.Digit) }


### Разделитель цепочек: separatedBy

Часто приходится иметь дело со случаем, когда множество элементов записываются подряд через некоторый разделитель:
это и CSV, определения списков или массивов, перечисления аргументов функции через запятую, и многие другое.
В Parboiled2 парсинг таких последовательностей делается легко и непринужденно:

    def CommaSeparatedNumbers = rule { oneOrMore(UnsignedInteger).separatedBy(",") }

Однако, первая версия использует для этого менее элегантный синтаксис:

    def CommaSeparatedNumbers = rule { oneOrMore(UnsignedInteger, separator = ",") }


### Оператор последовательности (~)

Для того чтобы указать, последовательность правил используется оператор `~`. В регулярных выражениях нет необходимости
в подобном операторе, там этот факт записывается непосредственным образом, так же, как и в некоторых сортах BNF. Для
примера напишем (предельно упрощённое) правило которое сопоставляет дату определенного формата:

    import CharPredicate.Digit
    
    // Дата должне иметь следующий формат: "yyyy-mm-dd"
    def SimplifiedRuleForDate = rule { Year ~ "-" ~ Month ~ "-" ~ Day } 
    
    def Year  = rule { Digit ~ Digit ~ Digit ~ Digit }
    def Month = rule { Digit ~ Digit }
    def Day   = rule { Digit ~ Digit }

Как видите, правило максимально упрощено, и я прекрасно отдаю отчет тому, что у нас может быть 99й месяц и 99й день
99го месяца. Не всегда при синтаксическом разборе имеет смысл задавать жесткие правила, например, если мы хотим передать
сопоставленную строку с датой в один из фабричных методов некоей DateTime библиотеки, которая все-равно проведет
валидацию, и вернет результат обернутый в Option. А вот грамматику мы заметно упростим. Не каждый сразу догадается что
[это регулярное выражение][re-email] описывает электронный адрес.

[re-email]: http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html


### «Необязательное» правило (optional)

Если бы существовало правило `zeroOrOne`, то это и был бы `optional`: либо есть одно вхождение, либо вхождений нет
совсем. Давайте разберем следующий пример: в разных семейства операционных систем маркер конца строки кодируется
по-разному. Например, в Unix-подобных операционных системах нужен только символ '\n', тогда как в Windows исторически
используется последовательность из двух симвловов: '\r' и '\n'. И если мы хотим обрабатывать текст, созданный в
любой из этих систем, то может использовать следующее правило для конца строки:

    def NewLine = rule { optional('\r') ~ '\n' }


### Упорядоченный выбор (|)

Аналог оператора `|` в регулярных выражениях, неспроста называемый *упорядоченным* выбором (ordered choice).
Предположим, что нам нужно распознать число, у которого может быть знак, а может и не может. Знак, если он есть,
бывает двух типов: положительный и отрицательный, разберемся сначала с ним:

    def Signum = rule { '+' | '-' }

Знак может вовсе отсутствовать в записи положительного числа:

    def MaybeSign = rule { optional(Signum) }

А само число число тогда представится в виде последовательности из знака числа и его модуля — числа без знака:

    def Integer = rule { MaybeSign ~ UnsignedInteger }

Порядок перечисления вариантов в правиле `Signum` имеет значение: выбирается самый первый из подошедших вариантов.
Это исключает возможность появление неоднозначности у грамматики. И да, так работают все без исключения PEG-парсеры.
Так что, если у вас стоит задача сопоставления операций языка C, начинать перечисление нужно с самых длинных, чтобы они
сопоставились первыми (так предписывает стандарт!). Упрощённо, правило может выглядеть, например, так:

    def COperator = rule {
      "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "^=" | "|=" | "<<=" | ">>=" |
      "<<" | ">>" | "<=" | ">=" | "==" | "!=" |
      "||" | "&&" | "->" | "++" | "--" |
      "<"  | ">"  | "+"  | "-"  | "&"  | "|" | "." |
      "*"  | "/"  | "!"  | "~"  | "^"  | "=" | ","
    }

Порядок перечислений может быть самым различным, но нужно обеспечить, чтобы в нём `+` всегда шёл после `+=` и `++`,
а `<` — после `<=` и `<<` (а `<<`, в свою очередь, после `<<=`). В противном случае может случиться, что составной
оператор присваивания `<<=` распарсится в последовательность [`<=`, `=`], а то и вовсе [`<`, `<`, `=`].

Если правило выбора становится избыточно сложным и не хочется полагаться на порядок его элементов, стоит сгруппировать
их по общим префиксам (факторизовать парсер):

    def COperators = rule {
      ("+" ~ optional("=" | "+")) |
      ("<" ~ optional("=" | ("<" ~ optional("=")))) | ...
    }

Заметим, однако, что ни один из наших примеров не сможет автоматически учитывать приоритеты операторов, для этого
придётся прибегнуть к более изощрёным правилам.


### Синтаксический сахар

Для `optional`, `oneOrMore` и `zeroOrMore` существует синтаксический сахар, позволяющий сделать определения ещё короче:
`.?`, `.+` и `.*`. Пожалуйста, используйте их мудро (или хотя бы не говорите никому, что это я вам про них рассказал):
при злоупотреблении ими, ваши правила будут читаться немногим лучше, чем регулярки. С помощью данных "ярлыков" для
правил мы можем сделать описание наших правил менее многословным:

    import CharPredicate.Digit
    def SignedInteger   = rule { (+ | -).? ~ Digit.+ }

И добавить поддержку массивов из целых чисел:

    def IntegerArray = rule {
      SignedInteger * (OptionalWhitespaces ~ ',' ~ OptionalWhitespaces)
    }

    // То же самое, но при этом лучше читается.
    def IntegerArray = rule {
      zeroOrMore(SignedInteger) separatedBy (OptionalWhitespaces ~ ',' ~ OptionalWhitespaces)
    }


### Запуск парсера

Для того, чтобы заставить написанный парсер сделать хоть что-то полезное, нужно вызвать метод `run` его главного
(корневого) правила. Если вы пишете модульный-тест для парсера, то возможно, иметь смысл вызывать этот метод и для
других правил). Скобочки после метода при этом обязательны.

Давайте заставим работать наш бесполезный парсер, умеющий сопоставлять только одну строковую константу. Итак, если
наш парсер определён следующим образом (не забываем про `EOI`):

    import org.parboiled2._

    class UselessParser(val input: ParserInput) extends Parser {
      def MyStringRule: Rule0 = rule { ignoreCase("Loneliness") ~ EOI }
    }

Теперь где-нибудь в другом месте создадим два экземплляра парсеров и подадим им на вход разные данные:

    val p1 = new UselessParser("Loneliness")
    val p2 = new UselessParser("Empty faces") 
    val p3 = new UselessParser("wish I could leave them all for some place else")

    // по-умолчанию возвращают scala.util.Try
    p1.MyStringRule.run()
    p2.MyStringRule.run()
    p3.MyStringRule.run()

Прогон правил в Parboiled2 намного проще чем в Parboiled1, для которого существует целый зоопарк раннеров (parser
runners), которые приходится дополнительно вызывать. За более подробной информацией прошу в раздел «Отчеты об ошибках»
части 4.


### Вложенные структуры данных

Разбор рекурсивных структур — это то, что может Parboiled и не могут регулярные выражения. В Parboiled это получается
естественно и непринужденно, что сейчас мы и продемонстрируем на последующих примерах. Единственное дополнительное
усилие которое от вас требуется — явно объявить тип правил, участвующих в рекурсии.

Разбор рекурсивных структур обычно иллюстрируют на примере калькулятора арифметических выражений. По моему мнению,
пример совершенно не нагляден. Поэтому мы рассмотрим вымышленный формат конфигурационных файлов, состоящий из
именованных блоков, содержащих пар «ключ—значение».


# Формат BKV (Block-Key-Value)

В качестве примера будет использоваться формат «BKV», который был придуман специально для этого туториала. Он
вдохновлялся форматом [HOCON][hocon] и, собственно, является его подмножеством. BKV состоит из пар ключ—значение и
блоков, внутри которых могут размещаться пары. Выглядит это примерно так:

[hocon]: https://github.com/typesafehub/config/blob/master/HOCON.md

    server_name = "webserver"
    server {
      port = "8080"
      address = "192.168.88.88"

      settings {
        greeting_message = "Hello!\n It's me!"
      }
    }

Как видите, формат прост и незатейлив, хотя строки с экранированием (escaping) могут напугать тех, кто никогда не
писал парсеры. Экранирование очень часто встречается при синтаксическом разборе, поэтому мы обязательно и в
подробностях его рассмотрим.


## Экранированные строки

Для того чтобы при синтаксическом разборе не иметь проблем с пробельными и непечатными символами, в большинстве
грамматик строки заключаются в двойные или одинарные кавычки (или их некое подобие, например могут использоваться
открывающие и закрывающие угловые скобки), внутри которых символы трактуются «как есть». К сожалению, при этом
теряется возможность поместить внутри строки сам символ кавычки, поэтому приходится предварять его каким-нибудь
другим символом.

Для того, чтобы написать парсер экранированных строк, необходимо определиться со следующими элементами синтаксиса:

 - Символы, открывающие и закрывающиие строку (в нашем случае это один и тот же символ — двойная кавычка).
 - Символ экранирования (в нашем случае это символ обратного слеша).
 - Набор символов-мнемоник для обозначения непечатных символов (мы будем поддерживать `'\n'`, `'\a'` и `'\f'`).

Давайте сначала попробуем описать правило для квотированной строки без экранирования:

    def DumbQuotedString = rule {
      '"' ~ zeroOrMore(AllowedChar) ~ '"'
    }

Поскольку пустые строки тоже возможны, мы используем правило `zeroOrMore` для символов, помещенных между кавычек.
Очевидно, что двойная кавычка в перечень допустимых символов не входит. Что разрешено? Все что не запрщено. Поэтому для
нашего случая список разрешенных символов выглядит так:

    def AllowedChar = rule { noneOf("\"") }

Без двойной кавычки жить можно, но сложно. Но что будет если мы ее добавим? Парсер ее встретит и подумает что строка
закончилась и взорвется с сообщениями об ошибке на следующем же символе.

Символ экранирования предупреждает парсер о том, что следущий символ особенный. Алгоритм выглядит таким образом: парсер
ожидает один из разрешенных символов или экранированную последовательность, а экранированная последовательность состоит
из символа экранирования и следующим за ним оператором выбора одного из символов.

    def AllowedChar = rule {
      noneOf("\"\\") | EscapeSequence
    }

    // Поддерживаются последовательности: \", \\, \n, \a, \f, \v
    def EscapeSequence = rule {
      '\' ~ anyOf("\"\\nafv")
    }

Разобравшись, как это работает, можно переходить к написанию финального варианта правил для экранирования. Для этого
предлагаю создать выделенный трейт:

    import org.parboiled2._

    object QuotedStringSupport {
      val CharsToBeEscaped = "abfnrtv\\\""
      val Backslash = '\\'
      val AllowedChars = CharPredicate.Printable -- Backslash -- '"'
    }

    trait QuotedStringSupport { this: Parser =>
      import QuotedStringSupport._

      def QuotedString: Rule0 = rule {
        '"' ~ QuotedStringContent  ~ '"'
      }

      def QuotedStringContent: Rule0 = rule {
        oneOrMore(AllowedChars | DoubleQuotedStringEscapeSequence)
      }

      def DoubleQuotedStringEscapeSequence = rule {
        '\\' ~ anyOf(CharsToBeEscaped)
      }
    }

Теперь, когда мы расквитались со строками и сохранили парсер в отдельный трейт, перейдем к самому формату.

## Вспомогательные терминалы

В написании парсеров существует два подхода: «от общего к частному» и «от частного к общему». Обычно грамматики
описываются согласно первому, но это всего-лишь туториал, поэтому начнем с деталей помельче, а затем обобщим.

Начем описание со вспомогательных элементов, а именно, с пробелов. В нашем случае пробелами будут являться символы:
' ', '\n' и '\t'. Конечно же, пробельных символов в природе существует куда больше, но в примере мы ограничимся тремя.
Разобраться с пробелами можно разными способами:

 - перечислить символы через оператор упорядоченного выбора;
 - объявить свой `CharPredicate`, содержащий эти три символа;
 - использовать `anyOf`.

Мы воспользуемся последним. При этом учтём, что в некоторых местах пробелов может быть несколько, в некоторых их может
не быть вовсе, а кое-где пробелы должны быть обязательно (но нашему формату обязательные пробелы не требуются):
Используемому формату обязательные пробелы не требуются.

    val WhitespaceChars = " \n\t"
    def Whitespace = rule { oneOrMore(anyOf(WhitespaceChars)) }
    def MayBeWs = rule { zeroOrMore(anyOf(WhitespaceChars)) }

Правило, описывающее перевод строки мы объявляли ранее:

    def Newline = rule { optional('\r') ~ '\n' }

В нашем случае Ключ и Имя блока представляют собой валидный идентификатор для большинства языков программирования.
Идентификатор может содержать цифры, буквы английского алфавита (строчные и заглавные), а так же символ подчеркивания
`_` и точку. Перед тем как объявлять ключ, объявим предикат, описывающий Идентификатор. (Аналогичные правила будут
применяться для имени блока)

    val IdentifierChar = CharPredicate.AlphaNum ++ "_" ++ "."

    // Являются идентификаторами
    val KeyChar = IdentifierChar
    val BlockNameChar = IdentifierChar

Объявим так же символы начала и конца блока:

    val BlockBeginning  = '{'
    val BlockEnding     = '}'

Все необходимые вспомогательные терминалы у нас объявлены. Перейдем к описанию пар.


## Пары ключ—значение

Теперь перейдём к синтаксису пар ключ–значение. Потребуем, чтобы ключ представлял собой валидный идентификатор, как
принято в большинства языков программирования: ему позволено содержать буквы английского алфавита (строчные и
заглавные), цифры, а также символ подчеркивания.

    def Key = rule { oneOrMore(KeyChar) }

Со значением нам будет немного проще (для этого нам всего-то нужно подмешать написанный нами ранее трейт):

    def Value = rule { DoubleQuotedString }

Теперь опишем правило для пары ключ-значение. Стоит еще раз напомнить о том, что Parboiled является PEG, из этого
следует, что нам постоянно нужно помнить о пробелах и сообщать правилу о местах, где они могут встречаться.

    def KeyValuePair = rule { Key ~ MayBeWS ~ "=" ~ MayBeWs ~ Value }


## Рекурсивно вложенные структуры 

Теперь мы реализуем блок, который может хранть одну или несколько пар ключ—значение или другие блоки. Для начала, нужно
«стереть» различия между блоками и парами ключ—значение. И те, и другие будут являться узлами (nodes) синтаксического
дерева. Описанное выше иллюстрируется следующим кодом:

    // Тип правила обязателен к указанию, иначе не взлетит!
    def Node: Rule0 = rule { KeyValuePair | Block }

Так как и блок, и корневая структура состоят из списка узлов, нам нужно объявить правило для этого списка:

    def Nodes = rule {
      MayBeWS ~ zeroOrMore(Node).separatedBy(Newline ~ MayBeWS) ~ MayBeWS
    }

Ноды разделяются символом перевода строки, пробелы могут быть перед списоком нод, после, и перед каждым блоком или
парой. Определим имя блока (в нашем случае это тот же идентификатор что используется в имени ключа):

    def BlockName = oneOrMore(BlockNameCharacter)

Все необходимое для объявления блока у нас уже есть, поэтому объявим имя блока:

    def Block = rule { BlockName ~ "{" ~ Nodes ~ "}" }

Помните мы определяли `BlockBeginning` и `BlockEnding`. Используем их в объявлении.

    def Block = rule { BlockName ~ BlockBeginning ~ Nodes ~ BlockEnding }

Заметьте, что Block ссылается на написанное нами правило Nodes, которое будет ссылаться на правило Node. Здесь возникает
цикл. Поэтому нам необходимо явно указать тип правила, успокоив и обнадежив Parboiled. В нашем случае тип правила будет
`Rule0`. Более подробно о правилах будет рассказано в следующей статье.

У нас все есть, не хватает только точки входа, или корня (Root). Корень представляет собой список узлов. Поэтмоу
используем правило для списка узлов и завершим его символом `EOI`:

    def Root: Rule0 = rule { Nodes ~ EOI }

Ознакомиться с исходным кодом примера, вы можете [здесь][gist].
На данном этапе мы написали простой распознаватель. Сопоставлять значения на практике приходится весьма редко, а вот
захватывать их "каждый раз" приходится постоянно. В следующей статье я расскажу вам "захватывающие истории", о типах
правил и чем они отличаются. Мы доведем распознаватель до состояния работоспособного парсера.

[gist]: https://gist.github.com/ppopoff/1bbf022327750f37ebcc
