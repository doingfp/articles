Генерация парсера по формату
======================================
** Парсим на scala с Parboiled **

# Введение
Приветствую вас, дорогие читатели.
В этой статье мы напишем небольшую систему, способную конструировать
парсер во время выполнения программы на основе заданного формата сообщений.
Сделано это будет на примере формата логов доступа (access logs) для
некоего абстрактного веб-сервера.

[pro-parboiled]: http://habrahabr.ru/post/270233

# Описание задачи
Парсинг лог-сообщений, особенно логов веб-серверов, задача не очень приятная:
сначала сообщения нужно распарсить, собрать на основе полей каждого сообщения
некий класс или структуру, где-нибудь сохранить и, возможно, посчитать на
основе полученных данных какую-нибудь статистику. Ухудшить ситуацию может лишь
количество сообщений, ежесекундно поступающих к вам на обработку. Решение
должно быть быстрым, и гибким (в случае, если пользователь может преднамеренно
изменить формат сообщений). Согласитесь, переписывать каждый раз код парсера
для этих целей не лучший способ потратить рабочий день. Столкнувшись с такой
проблемой в продакшне я решил ее раз и навсегда.

[Logstash][logstash] меня не устроил своей медлительностью, так же как и
парсинг сообщений при помощи регулярных выражений. Хотя стоит отметить
наличие гибких решений, облегчающих эту задачу, например [Java Grock][java-grock].

Java Grock позволяет генерировать строить "парсер" на основе изменяющегося
лог-формата. И выглядит следующим образом. Вы берете строку лог формата,
и делаете String.replace для всех ключей и заменяете их заранее
предопределенными паттернами
TODO:
показаться кому-то отличным решением проблемы. Проб

Проблему можно решить тривиальным образом, например воспользовавшись утилитой
, но использование подобной утилиты не всегда применимо.
Для кого-то проблемой может медлительность данного инструмента, для кого-то
наличие лишнего звена в архитектуре.
Лог сообщения можно так же распарсить при помощи регулярных выражений. Облегчить
эту задачу вам могут помочь библиотеки вроде .
Однако регулярные выражения не обладают гибкостью и работают медленно, в сравнении
с парсерами, написанными вручную.

[java-grock]: https://TODO

[logstash]: http://logstash.com

# Решение задачи

##

# Альтернативное решение
Dynamic rule dispatch
TODO: Спросить у Матиаса как вообще им пользоваться

# Заключение
Ну вот мы и построили парсер. бла бла бла
Исходные коды примеров можете найти тут: [ссылка]

# Благодарности
Сказать спасибо Яне и Владу, за то что вычитали статью и исправили мои ошибки.
