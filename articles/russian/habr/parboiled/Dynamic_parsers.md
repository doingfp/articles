Генерация парсера по формату с Parboiled
========================================
** Парсим на scala с Parboiled **

# Введение
Приветствую вас, дорогие читатели.
В этой статье мы напишем небольшую систему, способную конструировать парсер во время выполнения программы на
основе заданного формата сообщений. Сделано это будет на примере формата логов доступа (access logs) для
некоего абстрактного веб-сервера.

[pro-parboiled]: http://habrahabr.ru/post/270233

# Описание задачи
Парсинг лог-сообщений, особенно логов веб-серверов, задача не очень приятная: сообщения нужно распарсить,
собрать на основе полей каждого сообщения некий класс или структуру, [где-нибудь][elastic] сохранить и, возможно,
посчитать на основе полученных данных какую-нибудь статистику. Ухудшить ситуацию может лишь количество сообщений,
ежесекундно поступающих к вам на обработку. Решение должно быть быстрым, и гибким (в случае, если пользователь
может преднамеренно изменить формат сообщений). Согласитесь, переписывать каждый раз код парсера для этих целей не
лучший способ потратить рабочий день. Столкнувшись с такой проблемой в продакшне я решил ее раз и навсегда.

Большинство серверов приложений используют [Apache][apache]-[подобный][tomcat] формат для сообщений.
Исключениями, с которыми вам, возможно придется столкнуться являются [Glassfish][glassfish] и [nginx][nginx].

[elastic]: https://www.elastic.co/products/elasticsearch
[apache]: http://httpd.apache.org/docs/2.2/mod/mod_log_config.html#formats
[tomcat]: https://tomcat.apache.org/tomcat-7.0-doc/config/valve.html
[nginx]: http://nginx.org/en/docs/http/ngx_http_log_module.html
[glassfish]: http://pe-kay.blogspot.ru/2011/08/enabling-http-access-log-in-glassfish.html

## Зачем придумывать свой формат
TODO
TODO: описание своего формата

# Постановка задачи

# Существующие решения

## Logstash
[Logstash][logstash] меня не устроил в виду того что является приложением, а не библиотекой. Да и скорость его работы
оставляет желать лучшего.

[logstash]: http://logstash.com

## Регулярные выражения
Регулярки меня тоже не устроили. Читаются плохо, поддерживать неудобно, да и работать они не особо торопятся.
Хотя стоит отметить наличие гибких решений, облегчающих эту задачу, например [Java Grok][java-grok], который является
реализацией известного механизма в Logstash.


## Java Grok
Инструмент, позволяющий парсить различные типы логов. Представляет собой что-то вроде template engine для регулярных
выражений. Благодаря механизму [шаблонов][grok-patterns], читаемость выражений заметно облегчается. Существует
[множество][logstash-grok-patterns] предопределенных шаблонов, например для syslog или
[небезызвестного][apache-combined] формата лог сообщений сервера Apache. В последних версиях появилась возможность
сгенерировать json на основе входных данных.

[java-grok]: https://github.com/thekrakken/java-grok
[grok-patterns]: https://github.com/thekrakken/java-grok/blob/master/patterns/patterns
[logstash-grok-patterns]: https://github.com/elastic/logstash/blob/v1.4.2/patterns/grok-patterns
[apache-combined]: https://httpd.apache.org/docs/2.2/logs.html#combined

Java Grok позволяет строить парсер "на лету" на основе изменяющегося лог-формата, но он меня не устроил своей
строкотипизированностью. Для решения задачи приходится заменять ключи в строке, на основании которой будет
компилироваться шаблон.

    // Исходная строка с лог форматом
    // используем common потому что он по-проще
    val logFormat = "%h %l %u %t \"%r\" %>s %b"

    // Описываем шаблоны для каждого из извлекаемых полей.
    // Структура следующая: %{ИМЯ_ШАБЛОНА_В_ФАЙЛЕ:имяИзвлекаемогоЗначения}
    val httpTemplate = "%{HTTPDATE:timestamp}"
    val statusTemplate = "%{NUMBER:status}"

    // Заменяем ключи на шаблоны
    // Используем regexp для возможных модификаторов
    val preparedLogFormat =
      logFormat.replaceAllLiterally("%t", httpTemplate)
               .replaceAll("%[<>]?s", status)
               // ... и так для всех возможных вхождений

На основе полученного формата, с шаблонами вместо ключей, создаем объект Grok:

    val grok = Grok create "path/to/my/patterns"
        grok compile preparedLogFormat

В вашем файлике с шаблонами должны быть предопределены все используемые вами шаблоны:

    IPORHOST (?:%{HOSTNAME:UNWANTED}|%{IP:UNWANTED})
    HTTPDATE %{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} %{INT}
    ...

Парсим логи

    val logEventExapmle =
      """127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326"""

    val `match` = grok `match` logEvent
    val captures = `match`.captures()



Извлекать сопоставленные значения приходится по их строковым именам.


На момент решения мною этой задачи, эта библиотека была слишком молода.
Это быстрое и дешевое решение проблемы. Возможно, вам оно придется по душе.


## Parboiled
Parboiled работает [быстрее][pro-parboiled] регулярных выражений, а так же позволяет мне писать на Scala и
пользоваться благами строгой статической типизации. Однако, в случае с динамическим форматом для лог сообщений, встает
другая проблема: парсер детерминирован, и не может перестраиваться. Поэтому нам придется генерировать парсер прямо
во время выполнения программы.


# Решение задачи

## Java Grok
Решение простое до банальности:
Хоть combined и заранее предопределен, пример же должен из чего-то состоять?




## Parboiled



# Альтернативное решение
Dynamic rule dispatch
TODO: Спросить у Матиаса как вообще им пользоваться

# Заключение
Ну вот мы и построили парсер. бла бла бла
Исходные коды примеров можете найти тут: [ссылка]

# Благодарности
Сказать спасибо Яне и Владу, за то что вычитали статью и исправили мои ошибки.
